<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="OpenFOAM 场（field）的操作和运算"><meta name="keywords" content="field"><meta name="author" content="Yan Zhang"><meta name="copyright" content="Yan Zhang"><title>OpenFOAM 场（field）的操作和运算 | OpenFOAM 成长之路</title><link rel="shortcut icon" href="/album/192.jpg"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?38997e7d3b8e8c254bf0ddb7d2452127";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject="ga",e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script"),ga("create","UA-119919860-1","auto"),ga("send","pageview")</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容:${query}"}},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},hexoVersion:"6.3.0"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="OpenFOAM 成长之路" type="application/atom+xml"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#field-%E7%9B%B8%E5%85%B3%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">field 相关类的结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#field-%E7%9B%B8%E5%85%B3%E7%B1%BB%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">field 相关类的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0"><span class="toc-number">2.1.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96"><span class="toc-number">2.2.</span> <span class="toc-text">获取</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%BA%E7%9A%84%E6%93%8D%E4%BD%9C%E5%92%8C%E8%BF%90%E7%AE%97-field-operation-and-manipulation"><span class="toc-number">3.</span> <span class="toc-text">场的操作和运算 (Field Operation And Manipulation)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ioobject-%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">IOobject 中定义的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dimensionedfield-%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">DimensionedField 中定义的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#geometricfield-%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">GeometricField 中定义的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fieldfunctions"><span class="toc-number">3.4.</span> <span class="toc-text">FieldFunctions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dimensionedfieldfunctions"><span class="toc-number">3.5.</span> <span class="toc-text">DimensionedFieldFunctions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#geometricfieldfunctions"><span class="toc-number">3.6.</span> <span class="toc-text">GeometricFieldFunctions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fvc-%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">3.7.</span> <span class="toc-text">fvc 中的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volumeintegrate"><span class="toc-number">3.7.1.</span> <span class="toc-text">volumeIntegrate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#domainintegrate"><span class="toc-number">3.7.2.</span> <span class="toc-text">domainIntegrate</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/album/192.jpg"></div><div class="author-info__name text-center">Yan Zhang</div><div class="author-info__description text-center">OpenFOAM 成长之路</div><div class="follow-button"><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/ZhangYanTJU">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">43</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">35</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">8</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" target="_blank" rel="external nofollow noopener noreferrer" href="https://zmeng.tech/">Zmeng Blogs</a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">OpenFOAM 成长之路</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i> <span class="pull-right menus"><a class="site-page" href="/">首页</a><a class="site-page" href="/about">关于</a><a class="site-page" href="/release">Timeline</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i> <span>搜索</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">OpenFOAM 场（field）的操作和运算</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i> <a class="post-meta__categories" href="/categories/code-analysis/">code analysis</a><span class="post-meta__separator">|</span><span class="post-meta-wordcount"><span>字数总计:</span> <span class="word-count">3.9k</span><span class="post-meta__separator">|</span><span>阅读时长: 19 分钟</span></span></div><div class="article-container" id="post-content"><p><strong>F</strong>ield <strong>O</strong>peration <strong>A</strong>nd <strong>M</strong>anipulation</p><span id="more"></span><h1 id="field-相关类的结构"><a class="markdownIt-Anchor" href="#field-相关类的结构"></a> field 相关类的结构</h1><p>几个常见的类：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">volScalarField</span><br><span class="line">volVectorField</span><br><span class="line">surfaceScalarField</span><br><span class="line">surfaceVectorField</span><br></pre></td></tr></table></figure><p>其实它们都是别名，定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> GeometricField&lt;scalar, fvPatchField, volMesh&gt; volScalarField;<span class="comment">//src\finiteVolume\fields\volFields\volFieldsFwd.H</span></span><br><span class="line"><span class="keyword">typedef</span> GeometricField&lt;vector, fvPatchField, volMesh&gt; volVectorField;</span><br><span class="line"><span class="keyword">typedef</span> GeometricField&lt;scalar, fvsPatchField, surfaceMesh&gt; surfaceScalarField;<span class="comment">//src\finiteVolume\fields\surfaceFields\surfaceFieldsFwd.H</span></span><br><span class="line"><span class="keyword">typedef</span> GeometricField&lt;vector, fvsPatchField, surfaceMesh&gt; surfaceVectorField;</span><br></pre></td></tr></table></figure><p>发现，它们实际上都是 <code>GeometricField</code>，不过是提供的模板不同。<br>下面给出 <code>GeometricField</code> 类的 UML 类图。首先我们看到它需要三个模板：<code>&lt;Type,PatchField,GeoMesh&gt;</code>。<br>结合 <code>volScalarField</code> 和 <code>surfaceScalarField</code> 的定义，我们不难发现：第一个 <code>Type</code> 可以是 <code>scalar</code> <code>vector</code> 等，第二个 <code>PatchField</code> 可以是 <code>fvPatchField</code> <code>fvsPatchField</code>（这里的 s 表示 surface） 等，第三个 <code>GeoMesh</code> 可以是 <code>volMesh</code> <code>surfaceMesh</code> 等。</p><img src="http://www.plantuml.com/plantuml/svg/pLfBR-l65TxhLmoo4CIOHbAWArasu5ZsXO3OCcpVP2cCo97DNhumf6IxgbSjq4qBPD42HNv1Da6oxAR_fZVfp-YP5pap74gK7xUzYsjgvhpcp9aptpdaE4f8MaHPIiApYCGX6lrXFypkqttqZcG9AMaKyF5U4EEYi0P7DuyvyIzn6TpntpvCdvFYxcZTG_1lDaEND5hXag1paim9HMVBD2X1MG5pd6H_dcKneWI7ayKb9GL9ou5dpKpZy0Qij0cOzEKyZW9KWXKXMLH2z-G0dqXnGf2qQpXa_oFstpR2hx9b6cBwo1dq7oRZs7AVy8WISuGcQKbeYcEJg_OOfpyI0oqcQNJ3OP3a9Nj4wi5sT8XBN3atMPPu7XCKupc9KScSc8RamPfrxQbcOhsQpz623NnvMT8NYe2TN4t0CxKavM8qbm-SSTOvZbPP5F9euNp588394eKH9mDnVSzDLyLIc-GzjOLzO5j8-hqeZQCKTe5hgIaY-SI53pmnlv5ZPL9LkwueXaCkYtcqZt8Q9L4PhGWVksenPnSPfdQr2Nrp5zeKjP0xrss5O3jDNoSIqtpFYZAZHAQ2mcHlp9lJGdNgvXKhwHo_VPIvL3o7txPTdOaNsfSxnN0rGKOf2KgrRITP6aOyrfKnFEMcXB0T9vIaWRNCCib7bYag3xdDEGBk98Vi25bRdKXc0YWr17F5zpGgoHZors1Qb714a_usvPiKtpWSG4cC7wGXHO1ZJ16EypliDMZao7r6ONT832OFk8sB2CvJKp0t_JnApu5L6O-omcL17kE08DiRFd9kz6Rlzf6tW-YmlgegkPQ8fFAEJYm83ReexKQ77y0fg9MM2HgNBWFLF7uObxQ9IbxtGx51WxMiDvFDmeqyN_eE2U0LjRQk2UxB4qP1bm6ahlgkD5L8lPDfDlyTn6BV5x-P3lLSQRWcrJmxT937AiEOvaCRCW4Kmd6mZ04KS8A1vnsyiWrVHqNPH_SORj6GgsTwYWO13iebZci2T5XDlePHbUl_rzvn6VB9NLG19_aR02IJCh8T07deDSD1a_mMcbzWQurlDydeVlH1p5ElPzAZlVtzemhjzVYOLInMaw9CL3-x5uX6tMB2IxvWD0VeTZUpqFgYWTPDV3-muJQlFfhEuyzwubpcO10voSXYKHXGZQnml8Gf7I6mEE2ekt33wGeUJzhBWw_39PzTm1NEfo6-2XvWeaACrAIb8sxZam1dqi9NmvRJjAIF0psvV22FxC573YW3mT63EkW4LbIoxTz7TJZqv9beZ8kWg0T6CkhuqjPRAp26_9hC5ORf2Z9rbDG6aZQewNlTnIWcnUDUWRI-HghCkSozj-hC2q_QJOPUTVWSSyBNM_eIwrVleEZTZEfUUlsEXfO2KPqGzlMSNIVmuXdjWxhBf9y8dZR6a2FuOO7hwpEM1iXdsxi7pdoaPvvAjDzTeLc6rzxOq74mRZNDHKwMTcA7PFrk57OxPRh8wiFHYDUwyd7KacY0h8E7TY-rEgZShS3gkevAgfF1NhHLnpRW6C8hGl4jsKPsJwBREu1fnuAySc73075l64vudcJdycpfjlYMJe3oiUjqxD99O2dMSNtrh6jBlx56vYrrKWKXosVj2JE_eJWgYwrfRan05oL2MhP0nN8kqhij-LfEIAyhkgs82AE2q0X0DmXFSDuSfDKe3tEyBBDpd0-qqmq_Sq9PEPxBBCNT3AFnuraSvP2Ve1GazcKtUfCh-Zr7HS-wbbsMlUXQ9qdEQgoH29TlhiyocXp9lsWUPy47AKhq88iIqxBHrDAB1sVRwfamJOS9YrKDmcLmwqDMZBkkNjc9b5oo0ZMcMbBPAejb7Z6wupFjl0gqRGmbE8roKS2UOwX4v4iBqP7BLIMvlHu0bvS0S7I_sQMnB9nM4MLLAf9zlWTIVCEkNBKVQqhA9KtH0iS5ENXoy81JezkKlG-nUTZXSB84sJAFIRX91opkE03uNbWR8G3Y5Rc5qy0hcBcISj2-NxOYiOdAj6xRw7p7eGIQMsmADX20-pL45p5Q0qJidsD9F3OKMuEXdLIFHbkm2bA3jX6cDbSpZkjzPMarIczTLQmC4aT2re-jpCkUWuabTGU7sSFWMOctQ2eWUohgMmQfsirgPAqYVKUnXVks4UjjU3uFCKpY4ekYMxdn8Yida6G9n2Iuy41wzVFoBYhi4zLUk3S9lfMOHH8wR16efl2sB8R7q8Qwtj3j8DPtfPlxk90BPjqyMrBp-EpghIYDobFLqP1zBN6P06B9agGGxRhg4HqwfeT3VjD197jhbnBoYWgs-8ONISh1OcyDEAfZK0rweZMoF8SCrw6dBdhhzsgVJEyj7AG8ECqb3zvMVBMojhFxwiipFJjuM_5ljZpv_ahT1_A-MAp4G_tAY_todi_gTqvcDRXir4c07yqUbDQKalXH6rdpkaeCrsDcYubZITuahQuJaYuJYMEk0QQHzRlfTEn_TJn-qkRv5q0vkuVMv--lRsPNfyTZltgQJSvcvzFnv6noElRLmENLwVNfnOr_CUKqkZI-MYdk-FtDTFRjrUJc5EgNBncr-l4RdMKHnUJaZWGVU2vQiwyJmDeazwkdSrp0-V2ZD2kZnQFwAqQV733q0kh3y1HaZqpPFlhjaQMEaHOREs8S4BEAK_zz1quZz8Hjo4Kz1NlCu0QOfqQOCaO05m5Oc0QDSSYxE3PwRqtSAQVhZK8K_YfpQeUZ-tfOVjp5X10wvIBrcTiuc-FO6DVYXDd07sORNqQgI3IA9kOfUKBK8llLwdtt4gbyylKb7iheyeqL7geeyXqhFDIAv6SRLq_mlVaK9lkDFO4pmciKzs9g4m6htFq_M0WXyewaX4BImqOn9MnZ7-I8xuuCyBQjqDA8wlsp2m1-D2Nuqccj8sgpsITOIcZXtS9bLWQyFsN67RbdvDwQ6mkkamF0NkNrHjzlRRQdz7a9TFInQpvqi5CgszZLt-TmaGElsS76FA1PeQ_QTtN6rI0Jxkt6Rdy1q-GJ7-2Ltf2lSJ0SdcKCwFBjA3tFrvOuWESOujJpnGfXNc5hNUv4NTjRJErAv_J8YvXRliE4lReMLsAofNFJx3V7MVPXcK_fc2pmCZOoQFFDhj_o-eDzWo1zxEkx4mgXlFK395ONz_U4PjuNNw3__Fp7N__smw_V_-cNV_oaQKF__kUFCFZnkxzy_Ewl7__yhr_-_lCRhAMpeHrr7uVXJSQwwHNobHkggqOT_8Xsim-zXO7TbHzq3SIs3A_FTdkzffkuqfkBpLShLOFw5JldxYy0lRRtEkulA77OzctrdkDRVWVfK--_"><p><code>GeometricField</code> 类定义于 <code>src\OpenFOAM\fields\GeometricFields\GeometricField</code>。</p><ul><li><code>GeometricField</code> – 场 + 网格，包含内部场及其边界场，边界场是场的场（FieldField）</li><li><code>DimensionedField</code> – 带单位的场，只有内部场，没有边界场</li><li><code>Field</code> – 数组（即 List）+ 代数操作</li></ul><h1 id="field-相关类的用法"><a class="markdownIt-Anchor" href="#field-相关类的用法"></a> field 相关类的用法</h1><h2 id="构造"><a class="markdownIt-Anchor" href="#构造"></a> 构造</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">volScalarField <span class="title">A</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IOobject</span></span></span><br><span class="line"><span class="params"><span class="function">    (</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;A&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        mesh.time().timeName(),</span></span></span><br><span class="line"><span class="params"><span class="function">        mesh, <span class="comment">// 字典注册对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::MUST_READ, <span class="comment">// MUST_READ_IF_MODIFIED  NO_READ  READ_IF_PRESENT</span></span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::AUTO_WRITE, <span class="comment">// NO_WRITE</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="literal">true</span> <span class="comment">// 默认是注册</span></span></span></span><br><span class="line"><span class="params"><span class="function">    ),</span></span></span><br><span class="line"><span class="params"><span class="function">    mesh</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">volScalarField <span class="title">B</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IOobject</span></span></span><br><span class="line"><span class="params"><span class="function">    (</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;B&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        mesh.time().timeName(),</span></span></span><br><span class="line"><span class="params"><span class="function">        mesh,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::NO_READ,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::NO_WRITE</span></span></span><br><span class="line"><span class="params"><span class="function">    ),</span></span></span><br><span class="line"><span class="params"><span class="function">    mesh,</span></span></span><br><span class="line"><span class="params"><span class="function">    dimensionedScalar(dimensionSet(<span class="number">1</span>, <span class="number">-3</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0.</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// 量纲还可以：dimless，或者 dimMass/dimVolume</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>上述两种构造函数对应 <code>GeometricField</code> 源代码中的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">GeometricField</span>(<span class="type">const</span> IOobject&amp;,<span class="type">const</span> Mesh&amp;);</span><br><span class="line"><span class="built_in">GeometricField</span>(<span class="type">const</span> IOobject&amp;,<span class="type">const</span> Mesh&amp;,<span class="type">const</span> dimensioned&lt;Type&gt;&amp;,<span class="type">const</span> word&amp; patchFieldType=PatchField&lt;Type&gt;::<span class="built_in">calculatedType</span>());</span><br></pre></td></tr></table></figure><p>第一种是从文件中读取，内部场和边界场的初始值都由文件给定，边界条件也由文件给定。<br>第二种不需要从文件中读取，内部场和边界场的初始值都是这里给定的 0，边界条件默认是 <code>calculated</code>。也可以指定边界条件类型，如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">volScalarField <span class="title">C</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IOobject</span></span></span><br><span class="line"><span class="params"><span class="function">    (</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;C&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        mesh.time().timeName(),</span></span></span><br><span class="line"><span class="params"><span class="function">        mesh,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::NO_READ,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::NO_WRITE</span></span></span><br><span class="line"><span class="params"><span class="function">    ),</span></span></span><br><span class="line"><span class="params"><span class="function">    mesh,</span></span></span><br><span class="line"><span class="params"><span class="function">    dimensionedScalar(dimensionSet(<span class="number">1</span>, <span class="number">-3</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0.</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">    zeroGradientFvPatchScalarField::typeName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>下面介绍第三种构造方式，以一个量为蓝本，构造第二个</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">volScalarField <span class="title">D</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IOobject</span></span></span><br><span class="line"><span class="params"><span class="function">    (</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;D&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        mesh.time().timeName(),</span></span></span><br><span class="line"><span class="params"><span class="function">        mesh,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::READ_IF_PRESENT,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::AUTO_WRITE</span></span></span><br><span class="line"><span class="params"><span class="function">    ),</span></span></span><br><span class="line"><span class="params"><span class="function">    C</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>这个用法很有意思，当你提供了 <code>D</code> 时，它就会从文件读取；没提供时，它就会从 <code>C</code> 复制。<br>本人亲测。但是这个用法背后对应的代码有待挖掘。<br>它使用的是这个构造函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>, <span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">PatchField</span>, <span class="keyword">class</span> <span class="title class_">GeoMesh</span>&gt;</span><br><span class="line">Foam::GeometricField&lt;Type, PatchField, GeoMesh&gt;::<span class="built_in">GeometricField</span></span><br><span class="line">(</span><br><span class="line">    <span class="type">const</span> IOobject&amp; io,</span><br><span class="line">    <span class="type">const</span> GeometricField&lt;Type, PatchField, GeoMesh&gt;&amp; gf</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    <span class="built_in">Internal</span>(io, gf),</span><br><span class="line">    <span class="built_in">timeIndex_</span>(gf.<span class="built_in">timeIndex</span>()),</span><br><span class="line">    <span class="built_in">field0Ptr_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">    <span class="built_in">fieldPrevIterPtr_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">    <span class="built_in">boundaryField_</span>(*<span class="keyword">this</span>, gf.boundaryField_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">    &#123;</span><br><span class="line">        InfoInFunction</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Constructing as copy resetting IO params&quot;</span></span><br><span class="line">            &lt;&lt;endl &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">info</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">readIfPresent</span>() &amp;&amp; gf.field0Ptr_)</span><br><span class="line">    &#123;</span><br><span class="line">        field0Ptr_ = <span class="keyword">new</span> <span class="built_in">GeometricField</span>&lt;Type, PatchField, GeoMesh&gt;</span><br><span class="line">        (</span><br><span class="line">            io.<span class="built_in">name</span>() + <span class="string">&quot;_0&quot;</span>,</span><br><span class="line">            *gf.field0Ptr_</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>Internal</code> 的是 <code>DimensionedField</code> 的别名，调用的这个构造函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>, <span class="keyword">class</span> <span class="title class_">GeoMesh</span>&gt;</span><br><span class="line">DimensionedField&lt;Type, GeoMesh&gt;::<span class="built_in">DimensionedField</span></span><br><span class="line">(</span><br><span class="line">    <span class="type">const</span> IOobject&amp; io,</span><br><span class="line">    <span class="type">const</span> DimensionedField&lt;Type, GeoMesh&gt;&amp; df</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    <span class="built_in">regIOobject</span>(io),</span><br><span class="line">    <span class="built_in">Field</span>&lt;Type&gt;(df),</span><br><span class="line">    <span class="built_in">mesh_</span>(df.mesh_),</span><br><span class="line">    <span class="built_in">dimensions_</span>(df.dimensions_)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>需要注意一个场景，当你尝试这样使用时，是没问题的。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">volScalarField <span class="title">B</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IOobject</span></span></span><br><span class="line"><span class="params"><span class="function">    (</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;B&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        mesh.time().timeName(),</span></span></span><br><span class="line"><span class="params"><span class="function">        mesh,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::READ_IF_PRESENT,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::AUTO_WRITE</span></span></span><br><span class="line"><span class="params"><span class="function">    ),</span></span></span><br><span class="line"><span class="params"><span class="function">    A</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>但是如果你想的是继承 A 的边界类型，和量纲，但是数值想让它等于 0 的话。<br>你尝试这样做：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">volScalarField B</span><br><span class="line">(</span><br><span class="line">    IOobject</span><br><span class="line">    (</span><br><span class="line">        &quot;B&quot;,</span><br><span class="line">        mesh.time().timeName(),</span><br><span class="line">        mesh,</span><br><span class="line">        IOobject::READ_IF_PRESENT,</span><br><span class="line">        IOobject::AUTO_WRITE</span><br><span class="line">    ),</span><br><span class="line">    0.*A</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>就会出现问题，有些边界类型会变成 calculated。<br>原因如下：<br><code>0.*A</code> 调用的是定义于 GeometricFieldFunctionsM.C 中的这个函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TEMPLATE                                                                       \</span><br><span class="line">tmp&lt;GeometricField&lt;ReturnType, PatchField, GeoMesh&gt;&gt; <span class="keyword">operator</span> Op               \</span><br><span class="line">(                                                                              \</span><br><span class="line">    <span class="type">const</span> GeometricField&lt;Type1, PatchField, GeoMesh&gt;&amp; gf1                      \</span><br><span class="line">)                                                                              \</span><br><span class="line">&#123;                                                                              \</span><br><span class="line">    tmp&lt;GeometricField&lt;ReturnType, PatchField, GeoMesh&gt;&gt; tRes                  \</span><br><span class="line">    (                                                                          \</span><br><span class="line">        GeometricField&lt;ReturnType, PatchField, GeoMesh&gt;::New                   \</span><br><span class="line">        (                                                                      \</span><br><span class="line">            #Op + gf<span class="number">1.</span><span class="built_in">name</span>(),                                                  \</span><br><span class="line">            gf<span class="number">1.</span><span class="built_in">mesh</span>(),                                                        \</span><br><span class="line">            <span class="built_in">Dfunc</span>(gf<span class="number">1.</span><span class="built_in">dimensions</span>())                                            \</span><br><span class="line">        )                                                                      \</span><br><span class="line">    );                                                                         \</span><br><span class="line">                                                                               \</span><br><span class="line">    Foam::<span class="built_in">OpFunc</span>(tRes.<span class="built_in">ref</span>(), gf1);                                             \</span><br><span class="line">                                                                               \</span><br><span class="line">    <span class="keyword">return</span> tRes;                                                               \</span><br><span class="line">&#125;                                                                              \</span><br></pre></td></tr></table></figure><p>它返回一个 tmp 的场，通过这个 New 函数创建的（GeometricField.H）。注意，它的边界类型使用的默认 calculated！</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//- Return a temporary field constructed from name, mesh, dimensionSet</span></span><br><span class="line"><span class="comment">//  and patch type.</span></span><br><span class="line"><span class="type">static</span> tmp&lt;GeometricField&lt;Type, PatchField, GeoMesh&gt;&gt; <span class="built_in">New</span></span><br><span class="line">(</span><br><span class="line">    <span class="type">const</span> word&amp; name,</span><br><span class="line">    <span class="type">const</span> Mesh&amp;,</span><br><span class="line">    <span class="type">const</span> dimensionSet&amp;,</span><br><span class="line">    <span class="type">const</span> word&amp; patchFieldType=PatchField&lt;Type&gt;::<span class="built_in">calculatedType</span>() <span class="comment">// 这里有默认参数</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>, <span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">PatchField</span>, <span class="keyword">class</span> <span class="title class_">GeoMesh</span>&gt;</span><br><span class="line">Foam::tmp&lt;Foam::GeometricField&lt;Type, PatchField, GeoMesh&gt;&gt;</span><br><span class="line">Foam::GeometricField&lt;Type, PatchField, GeoMesh&gt;::<span class="built_in">New</span></span><br><span class="line">(</span><br><span class="line">    <span class="type">const</span> word&amp; name,</span><br><span class="line">    <span class="type">const</span> Mesh&amp; mesh,</span><br><span class="line">    <span class="type">const</span> dimensionSet&amp; ds,</span><br><span class="line">    <span class="type">const</span> word&amp; patchFieldType <span class="comment">// PatchField&lt;Type&gt;::calculatedType()</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp&lt;GeometricField&lt;Type, PatchField, GeoMesh&gt;&gt;</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">GeometricField</span>&lt;Type, PatchField, GeoMesh&gt;</span><br><span class="line">        (</span><br><span class="line">            <span class="built_in">IOobject</span></span><br><span class="line">            (</span><br><span class="line">                name,</span><br><span class="line">                mesh.<span class="built_in">thisDb</span>().<span class="built_in">time</span>().<span class="built_in">timeName</span>(),</span><br><span class="line">                mesh.<span class="built_in">thisDb</span>(),</span><br><span class="line">                IOobject::NO_READ,</span><br><span class="line">                IOobject::NO_WRITE,</span><br><span class="line">                <span class="literal">false</span></span><br><span class="line">            ),</span><br><span class="line">            mesh,</span><br><span class="line">            ds,</span><br><span class="line">            patchFieldType <span class="comment">// PatchField&lt;Type&gt;::calculatedType()</span></span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用了这个构造函数：</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>, <span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">PatchField</span>, <span class="keyword">class</span> <span class="title class_">GeoMesh</span>&gt;</span><br><span class="line">Foam::GeometricField&lt;Type, PatchField, GeoMesh&gt;::<span class="built_in">GeometricField</span></span><br><span class="line">(</span><br><span class="line">    <span class="type">const</span> IOobject&amp; io,</span><br><span class="line">    <span class="type">const</span> Mesh&amp; mesh,</span><br><span class="line">    <span class="type">const</span> dimensionSet&amp; ds,</span><br><span class="line">    <span class="type">const</span> word&amp; patchFieldType <span class="comment">// PatchField&lt;Type&gt;::calculatedType()</span></span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    <span class="built_in">Internal</span>(io, mesh, ds, <span class="literal">false</span>),</span><br><span class="line">    <span class="built_in">timeIndex_</span>(<span class="keyword">this</span>-&gt;<span class="built_in">time</span>().<span class="built_in">timeIndex</span>()),</span><br><span class="line">    <span class="built_in">field0Ptr_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">    <span class="built_in">fieldPrevIterPtr_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">    <span class="built_in">boundaryField_</span>(mesh.<span class="built_in">boundary</span>(), *<span class="keyword">this</span>, patchFieldType)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">    &#123;</span><br><span class="line">        InfoInFunction &lt;&lt;<span class="string">&quot;Creating temporary&quot;</span> &lt;&lt; endl &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">info</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">readIfPresent</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造 boundaryField_ 时，调用的是：</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>, <span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">PatchField</span>, <span class="keyword">class</span> <span class="title class_">GeoMesh</span>&gt;</span><br><span class="line">Foam::GeometricField&lt;Type, PatchField, GeoMesh&gt;::Boundary::</span><br><span class="line"><span class="built_in">Boundary</span></span><br><span class="line">(</span><br><span class="line">    <span class="type">const</span> BoundaryMesh&amp; bmesh,</span><br><span class="line">    <span class="type">const</span> DimensionedField&lt;Type, GeoMesh&gt;&amp; field,</span><br><span class="line">    <span class="type">const</span> word&amp; patchFieldType <span class="comment">// PatchField&lt;Type&gt;::calculatedType()</span></span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    <span class="built_in">FieldField</span>&lt;PatchField, Type&gt;(bmesh.<span class="built_in">size</span>()), <span class="comment">// Boundary 的基类</span></span><br><span class="line">    <span class="built_in">bmesh_</span>(bmesh) <span class="comment">// 成员变量 const BoundaryMesh&amp; bmesh_;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">    &#123;</span><br><span class="line">        InfoInFunction &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    forAll(bmesh_, patchi)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">set</span></span><br><span class="line">        (</span><br><span class="line">            patchi,</span><br><span class="line">            PatchField&lt;Type&gt;::<span class="built_in">New</span></span><br><span class="line">            (</span><br><span class="line">                patchFieldType, <span class="comment">// PatchField&lt;Type&gt;::calculatedType()</span></span><br><span class="line">                bmesh_[patchi],</span><br><span class="line">                field</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line">Foam::tmp&lt;Foam::fvPatchField&lt;Type&gt;&gt; Foam::fvPatchField&lt;Type&gt;::<span class="built_in">New</span></span><br><span class="line">(</span><br><span class="line">    <span class="type">const</span> word&amp; patchFieldType, <span class="comment">// PatchField&lt;Type&gt;::calculatedType()</span></span><br><span class="line">    <span class="type">const</span> fvPatch&amp; p,</span><br><span class="line">    <span class="type">const</span> DimensionedField&lt;Type, volMesh&gt;&amp; iF</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">New</span>(patchFieldType, word::null, p, iF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line">Foam::tmp&lt;Foam::fvPatchField&lt;Type&gt;&gt; Foam::fvPatchField&lt;Type&gt;::<span class="built_in">New</span></span><br><span class="line">(</span><br><span class="line">    <span class="type">const</span> word&amp; patchFieldType, <span class="comment">// PatchField&lt;Type&gt;::calculatedType()</span></span><br><span class="line">    <span class="type">const</span> word&amp; actualPatchType, <span class="comment">// word::null</span></span><br><span class="line">    <span class="type">const</span> fvPatch&amp; p, <span class="comment">// 网格边界类型，比如 wall patch cyclic symmetry</span></span><br><span class="line">    <span class="type">const</span> DimensionedField&lt;Type, volMesh&gt;&amp; iF</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">    &#123;</span><br><span class="line">        InfoInFunction</span><br><span class="line">            &lt;&lt; <span class="string">&quot;patchFieldType =&quot;</span> &lt;&lt; patchFieldType</span><br><span class="line">            &lt;&lt;<span class="string">&quot;:&quot;</span> &lt;&lt; p.<span class="built_in">type</span>()</span><br><span class="line">            &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typename</span> patchConstructorTable::iterator cstrIter =</span><br><span class="line">        patchConstructorTablePtr_-&gt;<span class="built_in">find</span>(patchFieldType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cstrIter == patchConstructorTablePtr_-&gt;<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        FatalErrorInFunction</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Unknown patchField type&quot;</span></span><br><span class="line">            &lt;&lt; patchFieldType &lt;&lt; nl &lt;&lt; nl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Valid patchField types are :&quot;</span> &lt;&lt; endl</span><br><span class="line">            &lt;&lt;patchConstructorTablePtr_-&gt;<span class="built_in">sortedToc</span>()</span><br><span class="line">            &lt;&lt;<span class="built_in">exit</span>(FatalError);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typename</span> patchConstructorTable::iterator patchTypeCstrIter =</span><br><span class="line">        patchConstructorTablePtr_-&gt;<span class="built_in">find</span>(p.<span class="built_in">type</span>()); <span class="comment">// 查找网格的边界类型，wall patch 不在这个列表里边</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span></span><br><span class="line">    (</span><br><span class="line">        actualPatchType == word::null</span><br><span class="line">     || actualPatchType != p.<span class="built_in">type</span>()</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (patchTypeCstrIter != patchConstructorTablePtr_-&gt;<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">patchTypeCstrIter</span>()(p, iF); <span class="comment">// 如果 cyclic，symmetry，则调用 cyclicFvPatchField， symmetryFvPatchField 的构造函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">cstrIter</span>()(p, iF); <span class="comment">// 如果 wall，patch，则调用 calculatedFvPatchField 的构造</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp&lt;fvPatchField&lt;Type&gt;&gt; tfvp = <span class="built_in">cstrIter</span>()(p, iF);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if constraint type override and store patchType if so</span></span><br><span class="line">        <span class="keyword">if</span> ((patchTypeCstrIter != patchConstructorTablePtr_-&gt;<span class="built_in">end</span>()))</span><br><span class="line">        &#123;</span><br><span class="line">            tfvp.<span class="built_in">ref</span>().<span class="built_in">patchType</span>() = actualPatchType;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tfvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给出一个解决方案，换一个构造函数即可：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">volScalarField <span class="title">B</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IOobject</span></span></span><br><span class="line"><span class="params"><span class="function">    (</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;B&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        mesh.time().timeName(),</span></span></span><br><span class="line"><span class="params"><span class="function">        mesh,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::READ_IF_PRESENT,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOobject::AUTO_WRITE</span></span></span><br><span class="line"><span class="params"><span class="function">    ),</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="number">0</span>*A,</span></span></span><br><span class="line"><span class="params"><span class="function">    A.boundaryField()</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>使用的是这个构造函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>, <span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">PatchField</span>, <span class="keyword">class</span> <span class="title class_">GeoMesh</span>&gt;</span><br><span class="line">Foam::GeometricField&lt;Type, PatchField, GeoMesh&gt;::<span class="built_in">GeometricField</span></span><br><span class="line">(</span><br><span class="line">    <span class="type">const</span> IOobject&amp; io,</span><br><span class="line">    <span class="type">const</span> Internal&amp; diField,</span><br><span class="line">    <span class="type">const</span> PtrList&lt;PatchField&lt;Type&gt;&gt;&amp; ptfl</span><br><span class="line">)</span><br><span class="line">:</span><br><span class="line">    <span class="built_in">Internal</span>(io, diField),</span><br><span class="line">    <span class="built_in">timeIndex_</span>(<span class="keyword">this</span>-&gt;<span class="built_in">time</span>().<span class="built_in">timeIndex</span>()),</span><br><span class="line">    <span class="built_in">field0Ptr_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">    <span class="built_in">fieldPrevIterPtr_</span>(<span class="literal">nullptr</span>),</span><br><span class="line">    <span class="built_in">boundaryField_</span>(<span class="keyword">this</span>-&gt;<span class="built_in">mesh</span>().<span class="built_in">boundary</span>(), *<span class="keyword">this</span>, ptfl)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">    &#123;</span><br><span class="line">        InfoInFunction</span><br><span class="line">            &lt;&lt;<span class="string">&quot;Constructing from components&quot;</span> &lt;&lt; endl &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">info</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">readIfPresent</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了常规的 <code>IOobject</code> 构造，还有复制构造：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tmp&lt;volScalarField&gt; tmagGradP = <span class="built_in">mag</span>(fvc::<span class="built_in">grad</span>(p));</span><br><span class="line"><span class="function">volScalarField <span class="title">normalisedGradP</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="string">&quot;normalisedGradP&quot;</span>,<span class="comment">// 如果不指定名字，默认是什么？</span></span></span></span><br><span class="line"><span class="params"><span class="function">    tmagGradP()/max(tmagGradP())</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="获取"><a class="markdownIt-Anchor" href="#获取"></a> 获取</h2><ul><li><p>const</p><ul><li><code>const Internal&amp; internalField() const</code>, 有量纲的内部场</li><li><code>const typename Internal::FieldType&amp; primitiveField() const</code>, 无量纲的内部场</li><li><code>const Boundary&amp; boundaryField() const</code>, 无量纲的边界场</li></ul></li><li><p>non-const</p><ul><li><code>Internal&amp; ref()</code>, 有量纲的内部场</li><li><code>typename Internal::FieldType&amp; primitiveFieldRef()</code>, 无量纲的内部场</li><li><code>Boundary&amp; boundaryFieldRef()</code>, 无量纲的边界场</li></ul></li></ul><p>用 <code>forAll</code> 来遍历的时候，遍历的其实就是那个 <code>field&lt;Type&gt;</code>。<br>所以总体是有量纲的，用 <code>forAll</code> 对每个 cell 或 face 遍历的时候，就失去量纲了。</p><p>使用举例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Info&lt;&lt;<span class="string">&quot;T============&quot;</span>&lt;&lt;T&lt;&lt;endl; <span class="comment">// 有量纲的 内部 + 边界</span></span><br><span class="line">Info&lt;&lt;<span class="string">&quot;T.internalField()============&quot;</span>&lt;&lt;T.<span class="built_in">internalField</span>()&lt;&lt;endl; <span class="comment">// 有量纲的 内部 + 边界</span></span><br><span class="line">Info&lt;&lt;<span class="string">&quot;T.primitiveField()============&quot;</span>&lt;&lt;T.<span class="built_in">primitiveField</span>()&lt;&lt;endl; <span class="comment">// 无量纲的 内部</span></span><br><span class="line">Info&lt;&lt;<span class="string">&quot;T.boundaryField()============&quot;</span>&lt;&lt;T.<span class="built_in">boundaryField</span>()&lt;&lt;endl; <span class="comment">// 无量纲的 边界</span></span><br><span class="line">Info&lt;&lt;<span class="string">&quot;T.ref()============&quot;</span>&lt;&lt;T.<span class="built_in">ref</span>()&lt;&lt;endl; <span class="comment">// 有量纲的 内部 + 边界</span></span><br><span class="line">Info&lt;&lt;<span class="string">&quot;T.primitiveFieldRef()============&quot;</span>&lt;&lt;T.<span class="built_in">primitiveFieldRef</span>()&lt;&lt;endl; <span class="comment">// 无量纲的 内部</span></span><br><span class="line">Info&lt;&lt;<span class="string">&quot;T.boundaryFieldRef()============&quot;</span>&lt;&lt;T.<span class="built_in">boundaryFieldRef</span>()&lt;&lt;endl; <span class="comment">// 无量纲的 边界</span></span><br></pre></td></tr></table></figure><p>T 文件：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dimensions [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">internalField uniform <span class="number">900</span>;</span><br><span class="line"></span><br><span class="line">boundaryField</span><br><span class="line">&#123;</span><br><span class="line">    walls</span><br><span class="line">    &#123;</span><br><span class="line">        type fixedValue;</span><br><span class="line">        value uniform <span class="number">1800</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T============dimensions      [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">internalField   uniform <span class="number">900</span>;</span><br><span class="line"></span><br><span class="line">boundaryField</span><br><span class="line">&#123;</span><br><span class="line">    walls</span><br><span class="line">    &#123;</span><br><span class="line">        type            fixedValue;</span><br><span class="line">        value           uniform <span class="number">1800</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T.<span class="built_in">internalField</span>()============dimensions      [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">internalField   uniform <span class="number">900</span>;</span><br><span class="line"></span><br><span class="line">boundaryField</span><br><span class="line">&#123;</span><br><span class="line">    walls</span><br><span class="line">    &#123;</span><br><span class="line">        type            fixedValue;</span><br><span class="line">        value           uniform <span class="number">1800</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T.<span class="built_in">primitiveField</span>()============<span class="number">8</span>&#123;<span class="number">900</span>&#125;</span><br><span class="line">T.<span class="built_in">boundaryField</span>()============</span><br><span class="line"><span class="number">1</span></span><br><span class="line">(</span><br><span class="line">    type            fixedValue;</span><br><span class="line">    value           uniform <span class="number">1800</span>;</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">T.<span class="built_in">ref</span>()============dimensions      [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">internalField   uniform <span class="number">900</span>;</span><br><span class="line"></span><br><span class="line">boundaryField</span><br><span class="line">&#123;</span><br><span class="line">    walls</span><br><span class="line">    &#123;</span><br><span class="line">        type            fixedValue;</span><br><span class="line">        value           uniform <span class="number">1800</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T.<span class="built_in">primitiveFieldRef</span>()============<span class="number">8</span>&#123;<span class="number">900</span>&#125;</span><br><span class="line">T.<span class="built_in">boundaryFieldRef</span>()============</span><br><span class="line"><span class="number">1</span></span><br><span class="line">(</span><br><span class="line">    type            fixedValue;</span><br><span class="line">    value           uniform <span class="number">1800</span>;</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里有一个奇怪的现象，即 ref 指的是内部场，但这里输出的确实内部 + 边界。不要被这里迷惑了，其它地方仍指的是内部场：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">dimensionedScalar <span class="title">A</span><span class="params">(dimTemperature, <span class="number">100.</span>)</span></span>;</span><br><span class="line">T.<span class="built_in">ref</span>() = A;</span><br><span class="line">Info&lt;&lt;<span class="string">&quot;T============&quot;</span>&lt;&lt;T&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T============dimensions      [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">internalField   uniform <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">boundaryField</span><br><span class="line">&#123;</span><br><span class="line">    walls</span><br><span class="line">    &#123;</span><br><span class="line">        type            fixedValue;</span><br><span class="line">        value           uniform <span class="number">1800</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="场的操作和运算-field-operation-and-manipulation"><a class="markdownIt-Anchor" href="#场的操作和运算-field-operation-and-manipulation"></a> 场的操作和运算 (Field Operation And Manipulation)</h1><h2 id="ioobject-中定义的函数"><a class="markdownIt-Anchor" href="#ioobject-中定义的函数"></a> IOobject 中定义的函数</h2><ul><li>writeOpt<br>使用举例：</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mu_.<span class="built_in">writeOpt</span>() = IOobject::AUTO_WRITE;</span><br></pre></td></tr></table></figure><h2 id="dimensionedfield-中定义的函数"><a class="markdownIt-Anchor" href="#dimensionedfield-中定义的函数"></a> DimensionedField 中定义的函数</h2><ul><li>平均</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">p.<span class="built_in">average</span>() = <span class="built_in">gAverage</span>(p)</span><br></pre></td></tr></table></figure><ul><li>加权平均</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">p.<span class="built_in">weightedAverage</span>(weightField) = <span class="built_in">gSum</span>(weightField*p)/<span class="built_in">gSum</span>(weightField)</span><br></pre></td></tr></table></figure><p>使用举例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Info&lt;&lt;<span class="string">&quot;average p is&quot;</span>&lt;&lt;p.<span class="built_in">weightedAverage</span>(mesh.<span class="built_in">V</span>()).<span class="built_in">value</span>()&lt;&lt;endl;</span><br><span class="line"><span class="comment">// 全场压力的体积加权平均值</span></span><br></pre></td></tr></table></figure><ul><li>dimensions<br>使用举例：</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Z_.<span class="built_in">dimensions</span>().<span class="built_in">reset</span>(dimless);</span><br></pre></td></tr></table></figure><h2 id="geometricfield-中定义的函数"><a class="markdownIt-Anchor" href="#geometricfield-中定义的函数"></a> GeometricField 中定义的函数</h2><ul><li>max, min<br>取最大值，包括内部场和边界场。并行计算时，Info 输出的是 master 的还是全局的？未测试<br>使用举例：</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Info&lt;&lt;<span class="string">&quot;T===&quot;</span>&lt;&lt;<span class="built_in">max</span>(T)&lt;&lt;endl;</span><br></pre></td></tr></table></figure><ul><li>writeMinMax<br>输出最小最大值，只包括内部场。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>, <span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">PatchField</span>, <span class="keyword">class</span> <span class="title class_">GeoMesh</span>&gt;</span><br><span class="line"><span class="type">void</span> Foam::GeometricField&lt;Type, PatchField, GeoMesh&gt;::<span class="built_in">writeMinMax</span></span><br><span class="line">(</span><br><span class="line">    Ostream&amp; os</span><br><span class="line">) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    os  &lt;&lt;<span class="string">&quot;min/max(&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;) =&quot;</span></span><br><span class="line">        &lt;&lt;Foam::<span class="built_in">min</span>(*<span class="keyword">this</span>).<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">        &lt;&lt;Foam::<span class="built_in">max</span>(*<span class="keyword">this</span>).<span class="built_in">value</span>()</span><br><span class="line">        &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用举例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Z_.<span class="built_in">writeMinMax</span>(Info);</span><br></pre></td></tr></table></figure><p>下面是详细的测试：<br>T 文件：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dimensions [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">internalField uniform <span class="number">900</span>;</span><br><span class="line"></span><br><span class="line">boundaryField</span><br><span class="line">&#123;</span><br><span class="line">    walls</span><br><span class="line">    &#123;</span><br><span class="line">        type fixedValue;</span><br><span class="line">        value uniform <span class="number">1800</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用举例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Info&lt;&lt;<span class="string">&quot;max(T)===&quot;</span>&lt;&lt;<span class="built_in">max</span>(T)&lt;&lt;endl; <span class="comment">// 内部 + 边界</span></span><br><span class="line">Info&lt;&lt;<span class="string">&quot;min(T)===&quot;</span>&lt;&lt;<span class="built_in">min</span>(T)&lt;&lt;endl; <span class="comment">// 内部 + 边界</span></span><br><span class="line">Info&lt;&lt;<span class="string">&quot;max(T.internalField)===&quot;</span>&lt;&lt;<span class="built_in">max</span>(T.<span class="built_in">internalField</span>())&lt;&lt;endl; <span class="comment">// 内部</span></span><br><span class="line">Info&lt;&lt;<span class="string">&quot;min(T.internalField)===&quot;</span>&lt;&lt;<span class="built_in">min</span>(T.<span class="built_in">internalField</span>())&lt;&lt;endl; <span class="comment">// 内部</span></span><br><span class="line">Info&lt;&lt;<span class="string">&quot;max(T.ref)===&quot;</span>&lt;&lt;<span class="built_in">max</span>(T.<span class="built_in">ref</span>())&lt;&lt;endl; <span class="comment">// 内部</span></span><br><span class="line">Info&lt;&lt;<span class="string">&quot;min(T.ref)===&quot;</span>&lt;&lt;<span class="built_in">min</span>(T.<span class="built_in">ref</span>())&lt;&lt;endl; <span class="comment">// 内部</span></span><br><span class="line">Info&lt;&lt;<span class="string">&quot;max(T.boundaryField)===&quot;</span>&lt;&lt;<span class="built_in">max</span>(T.<span class="built_in">boundaryField</span>())&lt;&lt;endl; <span class="comment">// 边界</span></span><br><span class="line">Info&lt;&lt;<span class="string">&quot;min(T.boundaryField)===&quot;</span>&lt;&lt;<span class="built_in">min</span>(T.<span class="built_in">boundaryField</span>())&lt;&lt;endl; <span class="comment">// 边界</span></span><br><span class="line">T.<span class="built_in">writeMinMax</span>(Info); <span class="comment">// 内部</span></span><br><span class="line">T.<span class="built_in">max</span>(<span class="number">1000</span>); <span class="comment">// 如有小于 1000 的，令其等于 1000，对内部和边界都起作用</span></span><br><span class="line">Info&lt;&lt;<span class="string">&quot;T===&quot;</span>&lt;&lt;T&lt;&lt;endl;</span><br><span class="line">T.<span class="built_in">max</span>(<span class="number">1900</span>);</span><br><span class="line">Info&lt;&lt;<span class="string">&quot;T===&quot;</span>&lt;&lt;T&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">max</span>(T)=== <span class="built_in">max</span>(T) [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>] <span class="number">1800</span></span><br><span class="line"><span class="built_in">min</span>(T)=== <span class="built_in">min</span>(T) [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>] <span class="number">900</span></span><br><span class="line"><span class="built_in">max</span>(T.internalField)=== <span class="built_in">max</span>(T) [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>] <span class="number">900</span></span><br><span class="line"><span class="built_in">min</span>(T.internalField)=== <span class="built_in">min</span>(T) [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>] <span class="number">900</span></span><br><span class="line"><span class="built_in">max</span>(T.ref)=== <span class="built_in">max</span>(T) [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>] <span class="number">900</span></span><br><span class="line"><span class="built_in">min</span>(T.ref)=== <span class="built_in">min</span>(T) [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>] <span class="number">900</span></span><br><span class="line"><span class="built_in">max</span>(T.boundaryField)=== <span class="number">1800</span></span><br><span class="line"><span class="built_in">min</span>(T.boundaryField)=== <span class="number">1800</span></span><br><span class="line">min/<span class="built_in">max</span>(T) = <span class="number">900</span>, <span class="number">900</span></span><br><span class="line">T=== dimensions      [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">internalField   uniform <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">boundaryField</span><br><span class="line">&#123;</span><br><span class="line">    walls</span><br><span class="line">    &#123;</span><br><span class="line">        type            fixedValue;</span><br><span class="line">        value           uniform <span class="number">1800</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T=== dimensions      [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">internalField   uniform <span class="number">1900</span>;</span><br><span class="line"></span><br><span class="line">boundaryField</span><br><span class="line">&#123;</span><br><span class="line">    walls</span><br><span class="line">    &#123;</span><br><span class="line">        type            fixedValue;</span><br><span class="line">        value           uniform <span class="number">1900</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边的 <code>T.max(1000)</code> 调用的是这个函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>, <span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class</span> <span class="title class_">PatchField</span>, <span class="keyword">class</span> <span class="title class_">GeoMesh</span>&gt;</span><br><span class="line"><span class="type">void</span> Foam::GeometricField&lt;Type, PatchField, GeoMesh&gt;::<span class="built_in">max</span></span><br><span class="line">(</span><br><span class="line">    <span class="type">const</span> dimensioned&lt;Type&gt;&amp; dt</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    Foam::<span class="built_in">max</span>(<span class="built_in">primitiveFieldRef</span>(), <span class="built_in">primitiveField</span>(), dt.<span class="built_in">value</span>());</span><br><span class="line">    Foam::<span class="built_in">max</span>(<span class="built_in">boundaryFieldRef</span>(), <span class="built_in">boundaryField</span>(), dt.<span class="built_in">value</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们之所以可以直接给它一个 scalar 实参（即上边的 1000），是因为有这样一个构造函数的存在：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line">Foam::dimensioned&lt;Type&gt;::<span class="built_in">dimensioned</span>(<span class="type">const</span> Type&amp; t)</span><br><span class="line">:</span><br><span class="line">    <span class="built_in">name_</span>(::Foam::<span class="built_in">name</span>(t)),</span><br><span class="line">    <span class="built_in">dimensions_</span>(dimless),</span><br><span class="line">    <span class="built_in">value_</span>(t)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>上边的 <code>Foam::max</code> 定义于 FieldFunctions.C 中的 <code>BINARY_TYPE_FUNCTION(Type, Type, Type, max)</code>。<br>这个宏在 FieldFunctionsM.H 中</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_TYPE_FUNCTION_SF(ReturnType, Type1, Type2, Func)                \</span></span><br><span class="line"><span class="meta">                                                                               \</span></span><br><span class="line"><span class="meta">TEMPLATE                                                                       \</span></span><br><span class="line"><span class="meta">void Func                                                                      \</span></span><br><span class="line"><span class="meta">(                                                                              \</span></span><br><span class="line"><span class="meta">    Field<span class="string">&lt;ReturnType&gt;</span>&amp; res,                                                    \</span></span><br><span class="line"><span class="meta">    const Type1&amp; s1,                                                           \</span></span><br><span class="line"><span class="meta">    const UList<span class="string">&lt;Type2&gt;</span>&amp; f2                                                     \</span></span><br><span class="line"><span class="meta">)                                                                              \</span></span><br><span class="line"><span class="meta">&#123;                                                                              \</span></span><br><span class="line"><span class="meta">    TFOR_ALL_F_OP_FUNC_S_F                                                     \</span></span><br><span class="line"><span class="meta">    (                                                                          \</span></span><br><span class="line"><span class="meta">        ReturnType, res, =, ::Foam::Func, Type1, s1, Type2, f2                 \</span></span><br><span class="line"><span class="meta">    )                                                                          \</span></span><br><span class="line"><span class="meta">&#125;                                                                              \</span></span><br><span class="line"><span class="meta">                                                                               \</span></span><br><span class="line"><span class="meta">TEMPLATE                                                                       \</span></span><br><span class="line"><span class="meta">tmp<span class="string">&lt;Field&lt;ReturnType&gt;</span>&gt; Func                                                    \</span></span><br><span class="line"><span class="meta">(                                                                              \</span></span><br><span class="line"><span class="meta">    const Type1&amp; s1,                                                           \</span></span><br><span class="line"><span class="meta">    const UList<span class="string">&lt;Type2&gt;</span>&amp; f2                                                     \</span></span><br><span class="line"><span class="meta">)                                                                              \</span></span><br><span class="line"><span class="meta">&#123;                                                                              \</span></span><br><span class="line"><span class="meta">    tmp<span class="string">&lt;Field&lt;ReturnType&gt;</span>&gt; tRes(new Field<span class="string">&lt;ReturnType&gt;</span>(f2.size()));             \</span></span><br><span class="line"><span class="meta">    Func(tRes.ref(), s1, f2);                                                  \</span></span><br><span class="line"><span class="meta">    return tRes;                                                               \</span></span><br><span class="line"><span class="meta">&#125;                                                                              \</span></span><br><span class="line"><span class="meta">                                                                               \</span></span><br><span class="line"><span class="meta">TEMPLATE                                                                       \</span></span><br><span class="line"><span class="meta">tmp<span class="string">&lt;Field&lt;ReturnType&gt;</span>&gt; Func                                                    \</span></span><br><span class="line"><span class="meta">(                                                                              \</span></span><br><span class="line"><span class="meta">    const Type1&amp; s1,                                                           \</span></span><br><span class="line"><span class="meta">    const tmp<span class="string">&lt;Field&lt;Type2&gt;</span>&gt;&amp; tf2                                               \</span></span><br><span class="line"><span class="meta">)                                                                              \</span></span><br><span class="line"><span class="meta">&#123;                                                                              \</span></span><br><span class="line"><span class="meta">    tmp<span class="string">&lt;Field&lt;ReturnType&gt;</span>&gt; tRes = reuseTmp<span class="string">&lt;ReturnType, Type2&gt;</span>::New(tf2);       \</span></span><br><span class="line"><span class="meta">    Func(tRes.ref(), s1, tf2());                                               \</span></span><br><span class="line"><span class="meta">    tf2.clear();                                                               \</span></span><br><span class="line"><span class="meta">    return tRes;                                                               \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_TYPE_FUNCTION_FS(ReturnType, Type1, Type2, Func)                \</span></span><br><span class="line"><span class="meta">                                                                               \</span></span><br><span class="line"><span class="meta">TEMPLATE                                                                       \</span></span><br><span class="line"><span class="meta">void Func                                                                      \</span></span><br><span class="line"><span class="meta">(                                                                              \</span></span><br><span class="line"><span class="meta">    Field<span class="string">&lt;ReturnType&gt;</span>&amp; res,                                                    \</span></span><br><span class="line"><span class="meta">    const UList<span class="string">&lt;Type1&gt;</span>&amp; f1,                                                    \</span></span><br><span class="line"><span class="meta">    const Type2&amp; s2                                                            \</span></span><br><span class="line"><span class="meta">)                                                                              \</span></span><br><span class="line"><span class="meta">&#123;                                                                              \</span></span><br><span class="line"><span class="meta">    TFOR_ALL_F_OP_FUNC_F_S                                                     \</span></span><br><span class="line"><span class="meta">    (                                                                          \</span></span><br><span class="line"><span class="meta">        ReturnType, res, =, ::Foam::Func, Type1, f1, Type2, s2                 \</span></span><br><span class="line"><span class="meta">    )                                                                          \</span></span><br><span class="line"><span class="meta">&#125;                                                                              \</span></span><br><span class="line"><span class="meta">                                                                               \</span></span><br><span class="line"><span class="meta">TEMPLATE                                                                       \</span></span><br><span class="line"><span class="meta">tmp<span class="string">&lt;Field&lt;ReturnType&gt;</span>&gt; Func                                                    \</span></span><br><span class="line"><span class="meta">(                                                                              \</span></span><br><span class="line"><span class="meta">    const UList<span class="string">&lt;Type1&gt;</span>&amp; f1,                                                    \</span></span><br><span class="line"><span class="meta">    const Type2&amp; s2                                                            \</span></span><br><span class="line"><span class="meta">)                                                                              \</span></span><br><span class="line"><span class="meta">&#123;                                                                              \</span></span><br><span class="line"><span class="meta">    tmp<span class="string">&lt;Field&lt;ReturnType&gt;</span>&gt; tRes(new Field<span class="string">&lt;ReturnType&gt;</span>(f1.size()));             \</span></span><br><span class="line"><span class="meta">    Func(tRes.ref(), f1, s2);                                                  \</span></span><br><span class="line"><span class="meta">    return tRes;                                                               \</span></span><br><span class="line"><span class="meta">&#125;                                                                              \</span></span><br><span class="line"><span class="meta">                                                                               \</span></span><br><span class="line"><span class="meta">TEMPLATE                                                                       \</span></span><br><span class="line"><span class="meta">tmp<span class="string">&lt;Field&lt;ReturnType&gt;</span>&gt; Func                                                    \</span></span><br><span class="line"><span class="meta">(                                                                              \</span></span><br><span class="line"><span class="meta">    const tmp<span class="string">&lt;Field&lt;Type1&gt;</span>&gt;&amp; tf1,                                              \</span></span><br><span class="line"><span class="meta">    const Type2&amp; s2                                                            \</span></span><br><span class="line"><span class="meta">)                                                                              \</span></span><br><span class="line"><span class="meta">&#123;                                                                              \</span></span><br><span class="line"><span class="meta">    tmp<span class="string">&lt;Field&lt;ReturnType&gt;</span>&gt; tRes = reuseTmp<span class="string">&lt;ReturnType, Type1&gt;</span>::New(tf1);       \</span></span><br><span class="line"><span class="meta">    Func(tRes.ref(), tf1(), s2);                                               \</span></span><br><span class="line"><span class="meta">    tf1.clear();                                                               \</span></span><br><span class="line"><span class="meta">    return tRes;                                                               \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINARY_TYPE_FUNCTION(ReturnType, Type1, Type2, Func)                   \</span></span><br><span class="line"><span class="meta">    BINARY_TYPE_FUNCTION_SF(ReturnType, Type1, Type2, Func)                    \</span></span><br><span class="line"><span class="meta">    BINARY_TYPE_FUNCTION_FS(ReturnType, Type1, Type2, Func)</span></span><br></pre></td></tr></table></figure><p>TFOR_ALL_F_OP_FUNC_S_F 和 TFOR_ALL_F_OP_FUNC_F_S 定义于 FieldM.H</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// member function : this f1 OP fUNC s, f2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFOR_ALL_F_OP_FUNC_S_F(typeF1, f1, OP, FUNC, typeS, s, typeF2, f2)     \</span></span><br><span class="line"><span class="meta">                                                                               \</span></span><br><span class="line"><span class="meta">    <span class="comment">/* check the two fields have same Field&lt;Type&gt; mesh */</span>                      \</span></span><br><span class="line"><span class="meta">    checkFields(f1, f2, <span class="string">&quot;f1&quot;</span> #OP <span class="string">&quot;&quot;</span>#FUNC<span class="string">&quot;(s, f2)&quot;</span>);                        \</span></span><br><span class="line"><span class="meta">                                                                               \</span></span><br><span class="line"><span class="meta">    <span class="comment">/* set access to f1, f2 and f3 at end of each field */</span>                     \</span></span><br><span class="line"><span class="meta">    List_ACCESS(typeF1, f1, f1P);                                              \</span></span><br><span class="line"><span class="meta">    List_CONST_ACCESS(typeF2, f2, f2P);                                        \</span></span><br><span class="line"><span class="meta">                                                                               \</span></span><br><span class="line"><span class="meta">    <span class="comment">/* loop through fields performing f1 OP1 f2 OP2 f3 */</span>                      \</span></span><br><span class="line"><span class="meta">    List_FOR_ALL(f1, i)                                                        \</span></span><br><span class="line"><span class="meta">        List_ELEM(f1, f1P, i) OP FUNC((s), List_ELEM(f2, f2P, i));             \</span></span><br><span class="line"><span class="meta">    List_END_FOR_ALL                                                           \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// member function : this f1 OP fUNC f2, s</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TFOR_ALL_F_OP_FUNC_F_S(typeF1, f1, OP, FUNC, typeF2, f2, typeS, s)     \</span></span><br><span class="line"><span class="meta">                                                                               \</span></span><br><span class="line"><span class="meta">    <span class="comment">/* check the two fields have same Field&lt;Type&gt; mesh */</span>                      \</span></span><br><span class="line"><span class="meta">    checkFields(f1, f2, <span class="string">&quot;f1&quot;</span> #OP <span class="string">&quot;&quot;</span>#FUNC<span class="string">&quot;(f2, s)&quot;</span>);                        \</span></span><br><span class="line"><span class="meta">                                                                               \</span></span><br><span class="line"><span class="meta">    <span class="comment">/* set access to f1, f2 and f3 at end of each field */</span>                     \</span></span><br><span class="line"><span class="meta">    List_ACCESS(typeF1, f1, f1P);                                              \</span></span><br><span class="line"><span class="meta">    List_CONST_ACCESS(typeF2, f2, f2P);                                        \</span></span><br><span class="line"><span class="meta">                                                                               \</span></span><br><span class="line"><span class="meta">    <span class="comment">/* loop through fields performing f1 OP1 f2 OP2 f3 */</span>                      \</span></span><br><span class="line"><span class="meta">    List_FOR_ALL(f1, i)                                                        \</span></span><br><span class="line"><span class="meta">        List_ELEM(f1, f1P, i) OP FUNC(List_ELEM(f2, f2P, i), (s));             \</span></span><br><span class="line"><span class="meta">    List_END_FOR_ALL</span></span><br></pre></td></tr></table></figure><p>接下来调用了 doubleScalar.H 中的 <code>MAXMINPOW(Scalar, Scalar, Scalar)</code> 因为 <code>max</code> 定义于这个宏里边。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXMINPOW(retType, type1, type2)          \</span></span><br><span class="line"><span class="meta">                                                  \</span></span><br><span class="line"><span class="meta">MAXMIN(retType, type1, type2)                     \</span></span><br><span class="line"><span class="meta">                                                  \</span></span><br><span class="line"><span class="meta">inline double pow(const type1 s, const type2 e)   \</span></span><br><span class="line"><span class="meta">&#123;                                                 \</span></span><br><span class="line"><span class="meta">    return ::pow(Scalar(s), Scalar(e));           \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">MAXMINPOW</span>(Scalar, Scalar, Scalar)</span><br><span class="line"><span class="built_in">MAXMINPOW</span>(Scalar, Scalar, <span class="type">int</span>)</span><br><span class="line"><span class="built_in">MAXMINPOW</span>(Scalar, <span class="type">int</span>, Scalar)</span><br><span class="line"><span class="built_in">MAXMINPOW</span>(Scalar, Scalar, <span class="type">long</span>)</span><br><span class="line"><span class="built_in">MAXMINPOW</span>(Scalar, <span class="type">long</span>, Scalar)</span><br><span class="line"><span class="built_in">MAXMINPOW</span>(Scalar, Scalar, <span class="type">float</span>)</span><br><span class="line"><span class="built_in">MAXMINPOW</span>(Scalar, <span class="type">float</span>, Scalar)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> MAXMINPOW</span></span><br></pre></td></tr></table></figure><p>MAXMIN 定义于 int.H</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXMIN(retType, type1, type2)              \</span></span><br><span class="line"><span class="meta">                                                   \</span></span><br><span class="line"><span class="meta">inline retType max(const type1 s1, const type2 s2) \</span></span><br><span class="line"><span class="meta">&#123;                                                  \</span></span><br><span class="line"><span class="meta">    return (s1&gt; s2)? s1: s2;                      \</span></span><br><span class="line"><span class="meta">&#125;                                                  \</span></span><br><span class="line"><span class="meta">                                                   \</span></span><br><span class="line"><span class="meta">inline retType min(const type1 s1, const type2 s2) \</span></span><br><span class="line"><span class="meta">&#123;                                                  \</span></span><br><span class="line"><span class="meta">    return (s1 &lt; s2)? s1: s2;                      \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>FieldFunctions.C 中还定义了几个诸如此类的函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TMP_UNARY_FUNCTION(ReturnType, Func)                                   \</span></span><br><span class="line"><span class="meta">                                                                               \</span></span><br><span class="line"><span class="meta">template<span class="string">&lt;class Type&gt;</span>                                                           \</span></span><br><span class="line"><span class="meta">ReturnType Func(const tmp<span class="string">&lt;Field&lt;Type&gt;</span>&gt;&amp; tf1)                                   \</span></span><br><span class="line"><span class="meta">&#123;                                                                              \</span></span><br><span class="line"><span class="meta">    ReturnType res = Func(tf1());                                              \</span></span><br><span class="line"><span class="meta">    tf1.clear();                                                               \</span></span><br><span class="line"><span class="meta">    return res;                                                                \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span></span><br><span class="line"><span class="function">Type <span class="title">max</span><span class="params">(<span class="type">const</span> UList&lt;Type&gt;&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Type <span class="title">Max</span><span class="params">(f[<span class="number">0</span>])</span></span>;</span><br><span class="line">        <span class="built_in">TFOR_ALL_S_OP_FUNC_F_S</span>(Type, Max, =, max, Type, f, Type, Max)</span><br><span class="line">        <span class="keyword">return</span> Max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> pTraits&lt;Type&gt;::min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TMP_UNARY_FUNCTION</span>(Type, max)</span><br></pre></td></tr></table></figure><p>那么 <code>max(T)</code> 调用的应该是这里。</p><ul><li>gMax<br><code>max</code> 的并行版，但是返回的是无量纲的值？</li></ul><h2 id="fieldfunctions"><a class="markdownIt-Anchor" href="#fieldfunctions"></a> FieldFunctions</h2><p>一些底层的函数，一般用不到</p><h2 id="dimensionedfieldfunctions"><a class="markdownIt-Anchor" href="#dimensionedfieldfunctions"></a> DimensionedFieldFunctions</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pow</span><br><span class="line">sqr</span><br><span class="line">magSqr</span><br><span class="line">mag</span><br><span class="line">cmptAv</span><br><span class="line">gMax</span><br><span class="line">gMin</span><br><span class="line">gSum</span><br><span class="line">gSumMag</span><br><span class="line">gAverage</span><br><span class="line">+</span><br><span class="line">-</span><br><span class="line">* 外积</span><br><span class="line">/</span><br><span class="line">^ 叉乘</span><br><span class="line">&amp; 点乘，内积</span><br><span class="line">&amp;&amp; 双内积</span><br></pre></td></tr></table></figure><h2 id="geometricfieldfunctions"><a class="markdownIt-Anchor" href="#geometricfieldfunctions"></a> GeometricFieldFunctions</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pow</span><br><span class="line">sqr</span><br><span class="line">magSqr</span><br><span class="line">mag</span><br><span class="line">cmptAv</span><br><span class="line">gMax 返回的是无量纲的？</span><br><span class="line">gMin</span><br><span class="line">gSum</span><br><span class="line">gSumMag</span><br><span class="line">gAverage</span><br><span class="line">+</span><br><span class="line">-</span><br><span class="line">* 外积</span><br><span class="line">/</span><br><span class="line">^ 叉乘</span><br><span class="line">&amp; 点乘，内积</span><br><span class="line">&amp;&amp; 双内积</span><br></pre></td></tr></table></figure><h2 id="fvc-中的操作"><a class="markdownIt-Anchor" href="#fvc-中的操作"></a> fvc 中的操作</h2><h3 id="volumeintegrate"><a class="markdownIt-Anchor" href="#volumeintegrate"></a> volumeIntegrate</h3><p>volumeIntegrate 的功能是对每个网格的某个物理量，乘以其网格体积，然后形成一个新的场。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">volumeIntegrate</span>(df) = df.<span class="built_in">mesh</span>().<span class="built_in">V</span>()*df.<span class="built_in">field</span>();</span><br></pre></td></tr></table></figure><h3 id="domainintegrate"><a class="markdownIt-Anchor" href="#domainintegrate"></a> domainIntegrate</h3><p>domainIntegrate 的功能是对某个物理量，乘以其网格体积，然后对所有网格求和。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">domainIntegrate</span>(df) = <span class="built_in">gSum</span>(fvc::<span class="built_in">volumeIntegrate</span>(df));</span><br></pre></td></tr></table></figure><p>这里的 gSum 是对全场求和。</p><p>其它 fvc 中的操作</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">surfaceIntegrate</span><br><span class="line">surfaceSum</span><br><span class="line">Su</span><br><span class="line">Sp</span><br><span class="line">SuSp</span><br><span class="line">snGrad</span><br><span class="line">reconstruct</span><br><span class="line">laplacian</span><br><span class="line">grad</span><br><span class="line">flux</span><br><span class="line">div</span><br><span class="line">DDt</span><br><span class="line">curl</span><br><span class="line">average</span><br><span class="line">cellReduce</span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noopener noreferrer" target="_blank">Yan Zhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://openfoam.top/fields/">https://openfoam.top/fields/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://openfoam.top">OpenFOAM 成长之路</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/field/">field</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/album/wechatPay.jpg"><div class="post-qr-code__desc">您的肯定会给我更大动力~</div></div></div><div class="social-share pull-right" data-disabled="tencent,douban,qzone,diandian,facebook,twitter,google"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/fvMesh/"><i class="fa fa-chevron-left"></i><span>fvMesh 简单分析（待补充）</span></a></div><div class="next-post pull-right"><a href="/lagrangian/"><span>OpenFOAM 拉格朗日库深度解析</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk=new Gitalk({clientID:"9dfad189aeefc4c2dde2",clientSecret:"69b4d95e0c4be2508135adae20b05bf6f298f386",repo:"zhangyantju.github.io",owner:"ZhangYanTJU",admin:"ZhangYanTJU",id:md5(decodeURI(location.pathname)),language:"zh-CN"});gitalk.render("gitalk-container")</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2024 By Yan Zhang</div><div class="framework-info"><span>驱动 -</span> <a target="_blank" rel="external nofollow noopener noreferrer" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 -</span> <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"),$("#top-container").addClass("is-mobile"))</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/wzpan/hexo-generator-search" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>
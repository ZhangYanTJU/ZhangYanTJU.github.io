<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="notes when reading C++ primer"><meta name="keywords" content="C++"><meta name="author" content="Yan Zhang"><meta name="copyright" content="Yan Zhang"><title>notes when reading C++ primer | OpenFOAM using &amp; programming skills</title><link rel="shortcut icon" href="/en/album/linktocat.ico"><link rel="stylesheet" href="/en/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?38997e7d3b8e8c254bf0ddb7d2452127";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-119919860-1","auto"),ga("send","pageview")</script><script>var GLOBAL_CONFIG={root:"/en/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"We didn't find any results for the search: ${query}"}},copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/en/atom.xml" title="OpenFOAM using & programming skills" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/album/192.jpg"></div><div class="author-info__name text-center">Yan Zhang</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/ZhangYanTJU" target="_blank" rel="external nofollow noopener noreferrer">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/en/archives"><span class="pull-left">Articles</span><span class="pull-right">17</span></a><a class="author-info-articles__tags article-meta" href="/en/tags"><span class="pull-left">Tags</span><span class="pull-right">16</span></a><a class="author-info-articles__categories article-meta" href="/en/categories"><span class="pull-left">Categories</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"><a id="site-name" href="/en/">OpenFOAM using &amp; programming skills</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"> <a class="site-page" href="/en">Home</a><a class="site-page" href="/en/about">About</a><a class="site-page" href="/en/subscribe">Subscribe</a><a class="site-page" href="../">简体中文</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">notes when reading C++ primer</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> created 2018-02-01<span class="post-meta__separator">|</span><i class="fa fa-calendar-check-o" aria-hidden="true"></i> updated 2018-05-03</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/en/categories/C/">C++</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">4.2k</span><span class="post-meta__separator">|</span><span>Reading time: 13 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>117 notes when reading C++ primer</p><a id="more"></a><div id="google_translate_element"></div><script type="text/javascript">function googleTranslateElementInit(){new google.translate.TranslateElement({pageLanguage:"zh-CN",layout:google.translate.TranslateElement.InlineLayout.SIMPLE,multilanguagePage:!0,gaTrack:!0,gaId:"UA-119919860-1"},"google_translate_element")}</script><script type="text/javascript" src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script><ol><li><code>++val</code> 和 <code>val=val+1</code> 等效。</li><li><code>tmp</code> 指针后边加括号，返回的是它所指的对象。</li><li>成员函数的调用方法：<code>对象.函数()</code>，<code>引用.函数()</code> 或<code>指针-&gt;函数</code> <code>.</code>称为点操作符，函数名后边必须加括号，括号里边是实参列表，可以为空，也可以是另一个对象。</li><li>无符号类型 <code>unsigned</code></li><li><code>std::cout</code> 中的 <code>::</code> 是作用域操作符，一个命名空间后边接一个对象名。</li><li>初始化分两种：直接初始化和复制初始化。<ul><li>直接初始化： <code>int ival(1024);</code></li><li>复制初始化： <code>int ival=1024;</code></li></ul></li><li>定义如何进行初始化的成员函数称为构造函数，构造函数可以有多个，每个构造接受不同数目或者类型的参数。 此外，如果定义某个类的变量时没有提供初始化式，则使用默认构造函数。如果没有默认构造函数，则必须提供显式的初始化式。</li><li>对象可以用任意复杂的表达式（包括函数的返回值）来初始化:</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> salary = <span class="number">99.99</span>, wage(salary + <span class="number">0.01</span>) ;          </span><br><span class="line"><span class="keyword">double</span> sale = sum(price,discount);</span><br></pre></td></tr></table></figure><ol start="11"><li>变量一定要初始化。</li><li>变量的定义（definition）用于为变量分配存储空间，还可以为变量指定初始值。在一个程序中，变量有且只有一个定义。</li><li>声明（declaration）用于向程序表明变量的类型和名字。定义也是声明：当定义变量时我们声明了它的类型和名字。可以通过使用extern关键字声明变量名而不定义它。不定义变量的声明包括对象名、对象类型和对象类型前的关键字extern</li><li><code>extern int i; // 声明但没有定义</code></li><li><code>int i; //声明并且定义了</code></li><li>变量可以申明多次，但只能定义一次。</li><li>例外，只有当 <code>extern</code> 声明位于函数外部时，才可以含有初始化式。 <code>extern double pi = 3.14</code> ( 声明并且定义了 )</li><li>变量必须且仅能定义一次，在使用变量前必须定义或声明变量。</li><li>多个文件共享一个变量，在一个文件中定义，其他文件中声明。</li><li>常量定义 <code>const int zuff = 512;</code></li><li>因为常量在定义后就不能修改，所以定义时必须初始化。</li><li>非 <code>const</code> 变量默认为 <code>extern</code>。要使 <code>const</code> 变量能够在其他的文件中访问，必须在定义它时显式地指定它为 <code>extern</code></li><li><code>int ival = 1024;</code></li><li><code>int &amp;refval = ival;</code></li><li>引用必须用与该引用同类型的对象初始化。</li><li>引用与被引用指向同一地址</li><li><code>const</code> 引用是指向 <code>const</code> 对象的引用，如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int ival &#x3D; 1024;</span><br><span class="line">const int &amp;refval  &#x3D; ival;</span><br></pre></td></tr></table></figure></li><li><code>const</code> 对象不能有非 <code>const</code> 引用，如 <code>Int &amp;ref2 = ival</code> 是错误的！</li><li><code>const</code> 引用可以初始化为不同类型的对象或者初始化为右值。如：</li><li><code>int i = 42; const int &amp;r = 42; const int &amp;r2 = r + i;</code><br>上边的这两种初始化对于非const引用却是不合法的。</li><li><code>typedef</code> 用于给类型起别名，如 <code>typedef double wage</code> 表示 wage 就是 double 类型的别名，可以用来定义对象</li><li>类 通过构造函数初始化数据成员</li><li>struct 也可以定义类</li><li>默认情况下，struct 的成员是 pubic，而 class 的成员是 private</li><li>头文件不能包含定义，只能有声明，但有三个例外：头文件可以定义类，值在编译时就已知的 const 对象和 inline 函数。</li><li>argc 是程序的参数数量，包含程序名本身</li><li>argv[] 指向命令行的每个字符</li><li>vector 是类模板， <code>vector&lt;int&gt; ival;</code> 类型放在尖括号中</li><li>双冒号（::）用法<ul><li>表示“域操作符”<br>例：声明了一个类 A，类 A 里声明了一个成员函数void f()，但没有在类的声明里给出f的定义，那么在类外定义 f 时，就要写成void A::f()，表示这个 f()函数是类A的成员函数</li></ul></li><li>c++ 中冒号（:）和双冒号（::）的用法 构造函数后边有一个冒号，那是初始化列表区</li><li>指针定义： <code>int a = 1; int *b = &amp;a;</code> * 是解引用操作符，&amp; 是取地址操作符。</li><li>指针本身是地址，* 加指针表示该存储在该地址的对象</li><li>指向 const 的指针，很明显，我们不能通过指针来修改这一数据，但我们可以改变指针所指对象啊。const double *ptr 这个特性可用作函数形参，防止在函数中修改这一变量。const double pi = 3.14; const double *ptr = π</li><li>const 指针： <code>int err = 0; int *const cur = &amp;err;</code> 只能指向这个对象，不能指其他人。必须在定义时初始化</li><li>指向 const 对象的 const 指针，既不能指向它处，也不能修改值。</li><li>函数的形参，如果是普通变量时，是按值传递的，即把实参复制一遍给形参。当使用指针或引用时，即为按址传递，但这样可能不安全（实参有被篡改的风险），所以有了const引用（或指向const的指针）的形参，这样既能按址传递，又能保护实参不被修改。 意思就是，我把实参传过去，只是让它起一些作用，我并不希望修改实参。所以就用const引用。</li><li>使用 const 引用形参有一个好处，即传递给他的实参既可以是 const 类型也可以是非 const 类型。而非 const 引用形参，只能传递给他非 const 实参，字面值常量也不允许传递给他，产生右值的表达式也不能传递给他。</li><li><ul><li>迭代器表示 vector 索引。相当于数组名加下标</li></ul></li><li>对于多维数组，ia[3][4] 表示三行四列，ia[2] 表示最后一行</li><li>可以将 a[3][2] 看成是一个具有 3 个元素的一维数组，因此 a.size()=3</li><li>通过引用传递数组，<code>return_type function(int (&amp;arr)[10]) { body }</code></li><li>返回引用的函数 在函数名前加 &amp;，最前边加上 const 表示返回值不可被修改。即，函数返回值不能当做左值，不能被赋值。</li><li>函数不能仅通过返回类型不同来重载</li><li><a href="http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777416.html" target="_blank" rel="external nofollow noopener noreferrer">C/C++ 中 const 关键字详解</a></li><li>常成员函数： <code>类名::fun(形参) const</code> 又名 const 成员函数，const 成员函数不能修改调用该函数的对象。</li><li>C++ 不允许在常量对象上调用成员函数，除非成员函数本身也被声明为常量。</li><li>当存在同名同参数和返回值的常量函数和非常量函数时，具体调用哪个函数是根据调用对象是常量对像还是非常量对象来决定的。常量对象调用常量成员；非常量对象调用非常量的成员。</li><li>对于非引用形参，const 和非 const 不可以重载。而对于引用或指针形参，const 和非 const 可以重载。<br>对于指针，说的是指向 const 对象的指针，并不是说 const 指针。对于引用，就是 const 引用，即指向 const 的引用。举例：<code>const 类型 &amp;或*</code></li><li>const 位于函数前中后，哪个可以重载？ 后！常量函数和非常量函数可以重载 中，也可以，不过需要引用形参</li><li>• const 在函数后面，保证函数不会修改调用对象。这是常量函数。<br>• const 在函数前面，用于当函数返回值是引用时，不能使用返回的引用来直接修改它指向的结构。<br>• const 在形数表中时，保证既能按引用传递，又不会改变实参原来的值。</li><li>带有默认实参的函数，调用它时，可以省略一个实参。重载的时候，这个默认参数可以不考虑，相当于这个参数不存在。</li><li>对于 const 引用形参的函数，它既可以用 const 实参来调用，也可以用非 const 实参来调用。但同时也存在非 const 形参的函数（即 const 形参和非const形参重载）时，非const实参优先调用非const形参的函数。</li><li>当形参以副本传递时，不能基于形参是否为 const 来实现来重载。就是说非引用形参</li><li>函数的形参可以是指向函数的指针。</li><li>类型转换 <code>static_cast&lt;int&gt;(2.56)</code> 将 2.56 转换成 int 型</li><li>C 风格的强制类型转换(Type Cast)很简单，不管什么类型的转换统统是：<code>TYPE b = (TYPE)a;</code></li><li><a href="http://www.cnblogs.com/goodhacker/archive/2011/07/20/2111996.html" target="_blank" rel="external nofollow noopener noreferrer">C++ 风格的类型转换</a></li><li>在类内部定义的成员函数，自动作为 inline 函数。</li><li>类外定义的函数，在前边加上 inline 就行，类内声明的时候，可以不加 inline。声明和定义，随便加一个 inline 就行。</li><li>const 指针：始终指向某个对象 int *const cur = &amp;err;<br>PS：指向 const 的指针： const int * abc = &amp;var;</li><li>const 引用：指向 const 的引用 const int &amp;refval = ival;</li><li>对于引用或指针形参，const 和非 const 可以重载。这里指的是是否指向 const 对象。</li><li>const函数和非 const 函数也可以重载。</li><li>调用类的成员使用点操作符，对于指针，使用-&gt;操作符。</li><li>定义默认构造函数的时候，如果其中有些成员数据的类型自身有默认构造函数，可以不初始化它，这样调用这个数据的默认构造函数。</li><li>构造函数不能声明为 const，因为他的作用本来就是给新建的对象赋初值，而 const 成员函数不能修改调用它的对象。</li><li>默认构造函数可以在冒号之后初始化，也可以在函数体内初始化。</li><li>但是有些成员，必须在冒号后，即初始化列表中初始化。这些成员是：没有默认构造函数的类型的成员，以及 const 或引用类型的成员。</li><li>构造函数冒号之后，函数体之前，那些变量应该都已经分配内存了，所以引用必须确定引用的对象是谁，const 也必须确定，没有默认构造函数的类型，也必须初始化。那些可以默认初始化的类型，随便都行，比如 int 之类的。</li><li>构造函数初始化的顺序是按类中定义的顺序，不管你在初始化中怎样的顺序。</li><li>逗号操作符从左至右计算每个表达式的值，并返回最右边操作数的值。有什么意义呢？</li><li>在基类中定义 virtual 函数，表示这个函数希望在派生类中重新定义。那么为什么要在基类中出现呢？基类不定义，派生类定义，这样不行吗？用于多态啊</li><li>基类希望派生类继承的函数不能定义为虚函数。</li><li>通过基类的引用（或指针）调用虚函数时，发生动态绑定。基类的引用既可以指向基类对象，也可以指向派生类对象，动态绑定表示运行时，被调用的函数根据引用指向的对象的实际类型来决定。</li><li>除了构造函数之外，任意非 static 成员函数都可以是虚函数。</li><li>private 成员只能由基类的成员和友元访问。派生类对基类 的public和private成员的访问权限同其他代码一样，并不是继承者就可以随意访问，它也无法使用基类的private成员。但有些成员需要派生类访问，所以有了protected。</li><li>protected 相当于给了派生类特权，可以访问基类的某些成员。</li><li>派生类只能通过派生类对象访问基类的 protected 成员，不能访问基类对象的 protected 成员。</li><li>基类提供给派生类的接口包括protected和public</li><li>派生 class classname:access_label base_class 可以指定多个基类.</li><li>派生类中虚函数的声明必须与基类中的定义方式完全一致。但有一个例外，返回对基类的引用的虚函数，派生类中的对应函数既可以返回对派生类的引用，也可以返回对基类的引用。</li><li>派生类定义虚函数时，可以加 virtual，也可以不加。虚函数不管继承多少次，永远是虚函数。</li><li>因为每个派生类对象都包含基类部分，所以可将基类类型的引用绑定到派生类对象的基类部分，也可以用指向基类的指针指向派生类对象。</li><li>任何可以在基类对象上执行的操作也可以通过派生类对象使用。</li><li>如果调用非虚函数，则无论实际对象是什么类型，都执行基类类型所定义的函数；虚函数则根据对象类型来判断。</li><li>使用 class 定义派生类默认具有 private 继承，使用 struct 定义派生类默认具有 public 继承。</li><li>友元可以访问类的 private 和 protected 成员。友元关系不能继承，基类的友元对派生类来说就是普通人一样。</li><li>如果基类和派生类都需要访问另一个类，则那个类必须将访问权限授予 基类和每一个派生类。</li><li>static 成员，相当于整个类的公有变量。对于他的所有派生类也一样，基类和派生类共享 static 成员。</li><li>因为派生类对象也是基类对象，所以存在从派生类引用到基类引用的自动转换，即，可以将派生类对象的引用转换为基类子对象的引用，对指针也类似。</li><li>但是，没有从基类引用到派生类引用的转换。</li><li>虽然一般可以使用派生类的对象对基类对象进行初始化或赋值，但，没有从派生类对象到基类对象的直接转换。只能通过引用或指针。</li><li>当一个函数的形参是基类引用时，可以将派生类对象当做实参，这样的话，形参引用直接绑定到派生类对象上。对象未被复制。</li><li>当一个函数的形参是基类对象时，可以将派生类对象当做实参，这样的话，派生类对象的基类部分复制到形参。</li><li>用派生类对象对基类对象进行初始化或赋值时，实际调用的是基类的复制构造函数和复制操作符，只是这些函数本应该传入一个基类对象，实际上传入的是派生类对象。</li><li>用派生类对象调用基类的复制构造函数或赋值操作符时，将发生下列步骤：</li><li>将派生类对象转换为基类引用，这仅仅意味着将一个基类引用绑定到派生类对象。</li><li>将该引用作为实参传给复制构造函数或赋值操作符。</li><li>那些操作符使用派生类的基类部分分别对调用构造函数或赋值的基类对象的成员进行初始化或赋值。</li><li>一旦操作符执行完毕，对象即为基类对象。它包含派生类的基类部分的副本，但实参的派生类部分被忽略。</li><li>当构造、复制、赋值和撤销派生类对象时，也会构造、复制、赋值和撤销这些基类子对象。</li><li>某些类需要只希望派生类使用的特殊构造函数，这样的构造函数应该定义为 protected。</li><li>派生类的构造函数受继承关系的影响，每个派生类构造函数除了初始化自己的数据成员之外，还要初始化基类。基类部分可以由默认构造函数初始化。</li><li>内置类型，无法默认初始化。</li><li>如果派生类构造函数没有定义基类成员，则自动调用基类默认构造函数，并且是先调用基类构造函数，然后运行派生类构造函数的初始化列表，最后再运行函数体。</li><li>也可以在派生类构造函数中显式指定基类的构造函数。</li><li>在基类构造函数或析构函数中，将派生类对象当做基类对象对待。这会影响动态绑定。</li><li>arugument 实参 parameter 形参</li><li>在普通的非 const 成员函数中，this 的类型是一个指向类类型的 const 指针。可以改变this 所指向的值，但不能改变 this 所保存的地址。<br>在 const 成员函数中，this 的类型是一个指向 const 类类型对象的 const 指针。既不能改变 this 所指向的对象，也不能改变 this 所保存的地址。<br>AAA</li></ol></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noopener noreferrer" target="_blank">Yan Zhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://openfoam.top/CppPrimer/">https://openfoam.top/CppPrimer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external nofollow noopener noreferrer">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/en/tags/C/">C++</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/album/wechatPay.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share pull-right" data-disabled="tencent,douban,qzone,diandian"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/en/T_calculate/"><i class="fa fa-chevron-left"></i><span>How to get temperature from enthalpy in OpenFOAM?</span></a></div><div class="next-post pull-right"><a href="/en/linuxLearning/"><span>Linux learning</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk=new Gitalk({clientID:"9dfad189aeefc4c2dde2",clientSecret:"69b4d95e0c4be2508135adae20b05bf6f298f386",repo:"zhangyantju.github.io",owner:"ZhangYanTJU",admin:"ZhangYanTJU",id:md5(decodeURI(location.pathname)),language:"en"});gitalk.render("gitalk-container")</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By Yan Zhang</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="external nofollow noopener noreferrer"><span>Melody</span></a></div><div class="footer_custom_text">Hosted by <a target="_blank" rel="external nofollow noopener noreferrer" href="https://pages.coding.me"><b>Coding Pages</b></a></div></div><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js?v=undefined"></script><script>if(window.mermaid){var options=JSON.parse(document.getElementById("maid-script").getAttribute("mermaidoptioins"));mermaid.initialize(options)}</script></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/en/js/utils.js?version=1.7.0"></script><script src="/en/js/fancybox.js?version=1.7.0"></script><script src="/en/js/sidebar.js?version=1.7.0"></script><script src="/en/js/copy.js?version=1.7.0"></script><script src="/en/js/fireworks.js?version=1.7.0"></script><script src="/en/js/transition.js?version=1.7.0"></script><script src="/en/js/scroll.js?version=1.7.0"></script><script src="/en/js/head.js?version=1.7.0"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/en/js/katex.js"></script><script src="/en/js/search/local-search.js"></script><script>/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"),$("#top-container").addClass("is-mobile"))</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49b1f5">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>
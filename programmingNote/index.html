<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="OpenFOAM 编程笔记"><meta name="keywords" content=""><meta name="author" content="Yan Zhang"><meta name="copyright" content="Yan Zhang"><title>OpenFOAM 编程笔记 | OpenFOAM 成长之路</title><link rel="shortcut icon" href="/album/linktocat.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?38997e7d3b8e8c254bf0ddb7d2452127";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject="ga",e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script"),ga("create","UA-119919860-1","auto"),ga("send","pageview")</script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容:${query}"}},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"}}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="OpenFOAM 成长之路" type="application/atom+xml"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#字典读取变量"><span class="toc-number">1.</span> <span class="toc-text">字典读取变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对某个量全场求和"><span class="toc-number">2.</span> <span class="toc-text">对某个量全场求和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-functionobject"><span class="toc-number">2.1.</span> <span class="toc-text">使用 functionObject</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#强行通过某个-const-接口修改变量"><span class="toc-number">3.</span> <span class="toc-text">强行通过某个 const 接口修改变量：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#场的加减乘除操作符同时包括内部场和边界场的操作"><span class="toc-number">4.</span> <span class="toc-text">场的加减乘除操作符，同时包括内部场和边界场的操作。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字典的三种使用方法"><span class="toc-number">5.</span> <span class="toc-text">字典的三种使用方法：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#路径"><span class="toc-number">6.</span> <span class="toc-text">路径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#未解之谜"><span class="toc-number">7.</span> <span class="toc-text">未解之谜</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/album/192.jpg"></div><div class="author-info__name text-center">Yan Zhang</div><div class="author-info__description text-center">OpenFOAM 成长之路</div><div class="follow-button"><a href="https://github.com/ZhangYanTJU" target="_blank" rel="external nofollow noopener noreferrer">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">39</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">30</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" href="https://zmeng.tech/" target="_blank" rel="external nofollow noopener noreferrer">Zmeng Blogs</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">OpenFOAM 成长之路</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i> <span class="pull-right menus"><a class="site-page" href="/">首页</a><a class="site-page" href="/about">关于</a><a class="site-page" href="/subscribe">订阅</a><a class="site-page" href="/en">English</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i> <span>搜索</span></a></span></div><div id="post-info"><div id="post-title">OpenFOAM 编程笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2018-06-25<span class="post-meta__separator">|</span><i class="fa fa-calendar-check-o" aria-hidden="true"></i> 更新于 2019-08-25</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/coding/">coding</a><div class="post-meta-wordcount"><span>字数总计:</span> <span class="word-count">1.5k</span><span class="post-meta__separator">|</span><span>阅读时长: 6 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>编写代码过程中用到的，或者搜集的一些代码片段。</p><a id="more"></a><h1 id="字典读取变量"><a class="markdownIt-Anchor" href="#字典读取变量"></a> 字典读取变量</h1><p>在求解器中由于计算需要，要求通过字典文件输入某个值：首先创建字典，然后从这个字典读取数据。<br>创建一个字典或者使用已有字典：</p><ul><li>创建字典：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IOdictionary transportProperties&#x2F;&#x2F;字典的变量名</span><br><span class="line">(</span><br><span class="line">    IOobject</span><br><span class="line">    (</span><br><span class="line">        &quot;transportProperties&quot;,&#x2F;&#x2F;字典名字</span><br><span class="line">        runTime.constant(),   &#x2F;&#x2F;字典位于constant下</span><br><span class="line">        mesh,</span><br><span class="line">        IOobject::MUST_READ_IF_MODIFIED,</span><br><span class="line">        IOobject::NO_WRITE</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>使用已有字典：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const dictionary&amp; subModelDict &#x3D; parcels.subModelProperties();&#x2F;&#x2F;这里要先获取已有的字典</span><br><span class="line">vector position &#x3D; subModelDict.subDict</span><br><span class="line">(</span><br><span class="line">    &quot;injectionModels&quot;</span><br><span class="line">).subDict(&quot;model1&quot;).lookup(&quot;position&quot;);</span><br><span class="line">&#x2F;&#x2F;子字典的用法可以参考这里</span><br></pre></td></tr></table></figure><p>然后从这个字典读取数据：</p><ul><li>读取 OF 定义的类型，如 <code>dimensionedScalar</code> 等，直接使用<code>lookup</code> 函数：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">word fuel(thermo.lookup(&quot;fuel&quot;));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dimensionedScalar DT</span><br><span class="line">(</span><br><span class="line">transportProperties.lookup(&quot;DT&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scalarList Z_param_(flameManDict.lookup(&quot;Z_param&quot;));</span><br></pre></td></tr></table></figure><ul><li>但是读取标量例外，需要这样用：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scalar Sct &#x3D; readScalar(transportProperties.lookup(&quot;Sct&quot;));</span><br></pre></td></tr></table></figure><p>另一个函数 <code>lookupOrdefault</code> 如何使用？<br>如下：</p><ul><li><code>B_(dict.lookupOrDefault(&quot;B&quot;, 5.5))</code></li><li><code>deltaByR1Min_(coeffDict_.lookupOrDefault&lt;scalar&gt;(&quot;deltaByR1Min&quot;, 0.0))</code></li><li><code>active_(lookupOrDefault&lt;Switch&gt;(&quot;active&quot;, true))</code></li><li><code>Cg_(lookupOrDefault&lt;scalar&gt;(&quot;Cg&quot;, 2.0))</code></li></ul><p>发现一个奇怪的地方：<br>case文件如下，可以看到D_NaCl需要两个word作为输入。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nu              [0 2 -1 0 0 0 0] 1e-05;</span><br><span class="line">D_NaCl_111         What  [0 2 -1 0 0 0 0] 0.01;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dimensionedScalar D_NaCl</span><br><span class="line">(</span><br><span class="line">    transportProperties.lookup(<span class="string">"D_NaCl_111"</span>)</span><br><span class="line">);</span><br><span class="line">Info&lt;&lt;<span class="string">"D_NaCl====="</span>&lt;&lt;D_NaCl&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//output:::::    D_NaCl=====What [0 2 -1 0 0 0 0] 0.01</span></span><br></pre></td></tr></table></figure><p>dimensionedScalar的三个私有数据，分别对应上述输出的三个量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class Type&gt;</span><br><span class="line">class dimensioned</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Private data</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;- Variable name</span><br><span class="line">        word name_;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;- The dimension set</span><br><span class="line">        dimensionSet dimensions_;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;- The data value</span><br><span class="line">        Type value_;</span><br></pre></td></tr></table></figure><p>那么lookup得到了这三个量，然后调用构造函数？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dimensioned(const word&amp;, const dimensionSet&amp;, const Type);</span><br></pre></td></tr></table></figure><p>那么 nu 呢？为什么只有 dimension 和 value?</p><p>声明</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dimensionedScalar nu0_;</span><br><span class="line">volScalarField nu_;</span><br></pre></td></tr></table></figure><p>定义</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nu0_(&quot;nu&quot;, dimViscosity, viscosityProperties_),</span><br><span class="line">nu_&#x2F;&#x2F;nu_ 是用一个 dimensionedScalar 构造出来的。</span><br><span class="line">(</span><br><span class="line">    IOobject</span><br><span class="line">    (</span><br><span class="line">        name,</span><br><span class="line">        U_.time().timeName(),</span><br><span class="line">        U_.db(),</span><br><span class="line">        IOobject::NO_READ,</span><br><span class="line">        IOobject::NO_WRITE</span><br><span class="line">    ),</span><br><span class="line">    U_.mesh(),</span><br><span class="line">    nu0_</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>读取数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool Foam::viscosityModels::Newtonian::read</span><br><span class="line">(</span><br><span class="line">    const dictionary&amp; viscosityProperties</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    viscosityModel::read(viscosityProperties);</span><br><span class="line">    viscosityProperties_.lookup(&quot;nu&quot;) &gt;&gt; nu0_;</span><br><span class="line">    nu_ &#x3D; nu0_;</span><br><span class="line">    &#x2F;&#x2F;volScalarField &#x3D; dimensionedScalar 均匀场</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这里的问题就变成了 <code>nu0_</code> 和 <code>D_NaCl</code> 的区别了，再看一下他们 <code>lookup</code> 的具体函数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">viscosityProperties_.lookup(&quot;nu&quot;) &gt;&gt; nu0_;</span><br><span class="line">&#x2F;&#x2F;这里的 &#96;lookup&#96; 获取了 dimension value 两个值</span><br><span class="line">&#x2F;&#x2F;为什么两个值就够了？</span><br><span class="line"></span><br><span class="line">dimensionedScalar D_NaCl</span><br><span class="line">(</span><br><span class="line">    transportProperties.lookup(&quot;D_NaCl_111&quot;)</span><br><span class="line">    &#x2F;&#x2F;这里 &#96;lookup&#96; 得到了 name dimension value 三个值</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>nu_</code> 输出是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">turbulence.nu&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;dimensions      [0 2 -1 0 0 0 0];</span><br><span class="line"></span><br><span class="line">internalField   uniform 1e-05;</span><br><span class="line"></span><br><span class="line">boundaryField</span><br><span class="line">&#123;</span><br><span class="line">    movingWall</span><br><span class="line">    &#123;</span><br><span class="line">        type            calculated;</span><br><span class="line">        value           uniform 1e-05;</span><br><span class="line">    &#125;</span><br><span class="line">    fixedWalls</span><br><span class="line">    &#123;</span><br><span class="line">        type            calculated;</span><br><span class="line">        value           uniform 1e-05;</span><br><span class="line">    &#125;</span><br><span class="line">    frontAndBack</span><br><span class="line">    &#123;</span><br><span class="line">        type            empty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，体标量场没有name，只有dimension和值？值分为内部场值和边界值。</p><h1 id="对某个量全场求和"><a class="markdownIt-Anchor" href="#对某个量全场求和"></a> 对某个量全场求和</h1><h2 id="使用-functionobject"><a class="markdownIt-Anchor" href="#使用-functionobject"></a> 使用 functionObject</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">functions</span><br><span class="line">&#123;</span><br><span class="line">    minMax</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Type of functionObject</span></span><br><span class="line">        type            cellSource;</span><br><span class="line">        <span class="comment">// Where to load it from (if not already in solver)</span></span><br><span class="line">        functionObjectLibs (<span class="string">"libfieldFunctionObjects.so"</span>);</span><br><span class="line">        <span class="comment">// Function object enabled flag</span></span><br><span class="line">        enabled         <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// Log to output (default: false)</span></span><br><span class="line">        <span class="built_in">log</span>             <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// Write information to file (default: true)</span></span><br><span class="line">        <span class="built_in">write</span>           <span class="literal">true</span>;</span><br><span class="line">        location        no;</span><br><span class="line">        <span class="comment">// Fields to be monitored - runTime modifiable</span></span><br><span class="line">        fields (dQ);</span><br><span class="line">        <span class="comment">//fields (T);</span></span><br><span class="line">        writeControl    timeStep;</span><br><span class="line">        writeInterval   <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="强行通过某个-const-接口修改变量"><a class="markdownIt-Anchor" href="#强行通过某个-const-接口修改变量"></a> 强行通过某个 <code>const</code> 接口修改变量：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">volScalarField&amp; mu_ &#x3D; const_cast&lt;volScalarField&amp;&gt;(this-&gt;thermo().mu()());</span><br></pre></td></tr></table></figure><p>这样就可以修改热物理库中的 <code>mu_</code> 了。</p><h1 id="场的加减乘除操作符同时包括内部场和边界场的操作"><a class="markdownIt-Anchor" href="#场的加减乘除操作符同时包括内部场和边界场的操作"></a> 场的加减乘除操作符，同时包括内部场和边界场的操作。</h1><p>哪些类有 <code>lookupOrDefault</code> 这个方法？已知的有：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dimensioned&lt;Type&gt;</span><br><span class="line">dictionary中是一个模板函数</span><br></pre></td></tr></table></figure><p>用法举例：</p><ul><li><p><code>active_(lookupOrDefault&lt;Switch&gt;(&quot;active&quot;, true))</code> 这是在初始化列表中使用，当前类继承自 <code>IOdictionary</code>。</p></li><li><p><code>Cg_(lookupOrDefault&lt;scalar&gt;(&quot;Cg&quot;, 2.0))</code> 这是在初始化列表中使用，当前类继承自 <code>IOdictionary</code>。</p></li><li><p><code>const int nNonOrthCorr(dictionary.lookupOrDefault&lt;int&gt;(&quot;nNonOrthogonalCorrectors&quot;, 0));</code></p></li><li><p><code>scalar maxDeltaT(Dict_.lookupOrDefault&lt;scalar&gt;(&quot;maxDeltaT&quot;, great));</code></p></li><li><p><code>B_(Dict_.lookupOrDefault(&quot;B&quot;, 5.5))</code> 这里为什么不需要提供模板？ B_ 是个 scalar</p></li><li><p><code>deltaByR1Min_(Dict_.lookupOrDefault&lt;scalar&gt;(&quot;deltaByR1Min&quot;, 0.0))</code></p></li><li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dimensionedScalar Tmax;</span><br><span class="line">Tmax(Dict_.subDict(&quot;subName&quot;).lookup(&quot;Tmax&quot;)),</span><br><span class="line">这里需要字典里边给定它的值和量纲，格式如下：</span><br><span class="line">Tmax     Tmax    [0 0 0 1 0 0 0] 2800.0;</span><br></pre></td></tr></table></figure></li><li><p><code>RASModel</code> 的构造函数里边的这个 <code>IOdictionary</code> 是什么用法？这里的 <code>RASModel</code> 是继承自 <code>IOdictionary</code> 的，所以在构造函数的初始化列表里边，需要先初始化基类的成员，然后正是因为继承关系，所以可以直接使用 <code>IOdictionary</code> 里边的 <code>lookup</code> 等函数！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RASModel::RASModel(...)</span><br><span class="line">:</span><br><span class="line">    turbulenceModel(rho, U, phi, thermophysicalModel, turbulenceModelName),</span><br><span class="line">    IOdictionary</span><br><span class="line">    (</span><br><span class="line">        IOobject</span><br><span class="line">        (</span><br><span class="line">            &quot;RASProperties&quot;,</span><br><span class="line">            U.time().constant(),</span><br><span class="line">            U.db(),</span><br><span class="line">            IOobject::MUST_READ_IF_MODIFIED,</span><br><span class="line">            IOobject::NO_WRITE</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">    turbulence_(lookup(&quot;turbulence&quot;)),</span><br><span class="line">    printCoeffs_(lookupOrDefault&lt;Switch&gt;(&quot;printCoeffs&quot;, false)),</span><br><span class="line">    coeffDict_(subOrEmptyDict(type + &quot;Coeffs&quot;)),</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="字典的三种使用方法"><a class="markdownIt-Anchor" href="#字典的三种使用方法"></a> 字典的三种使用方法：</h1><ul><li>创建字典文件<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CCMProperties</span><br><span class="line">(</span><br><span class="line">    IOobject</span><br><span class="line">    (</span><br><span class="line">        <span class="string">"CCMProperties"</span>,</span><br><span class="line">        <span class="keyword">this</span>-&gt;mesh().time().constant(),</span><br><span class="line">        <span class="keyword">this</span>-&gt;mesh(),</span><br><span class="line">        IOobject::MUST_READ,</span><br><span class="line">        IOobject::NO_WRITE,</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    )</span><br><span class="line">),</span><br></pre></td></tr></table></figure></li><li>创建某个文件中的字典中的子字典，无须创建，再使用一个 <code>subDict</code> ，如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dimensionedScalar Prandtl;</span><br><span class="line">Prandtl(CCMProperties.subDict(&quot;CCM&quot;).lookup(&quot;Prandtl&quot;)),</span><br></pre></td></tr></table></figure></li></ul><h1 id="路径"><a class="markdownIt-Anchor" href="#路径"></a> 路径</h1><p><code>db().time().rootPath()</code> 当前算例的上级目录。<br><code>db().path()</code> 当前运行目录，相当于在运行时执行 <code>pwd</code> 出现的结果。串行时为当前目录，并行时为每一个 processor*，不同的核对应各自的 processor*。<br><code>db().time().globalCaseName()</code> 当前算例的文件夹的名字。<br><code>db().time().timeName()</code> 是当前时间的字符串。</p><p>如果是 collated 模式，则没有 processor* 文件夹，只有 <strong>processors+核数</strong>这个文件夹，想要输出一个文件到这里，可以这么做：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">ostringstream</span> nProcs;</span><br><span class="line">nProcs&lt;&lt;Pstream::nProcs();</span><br><span class="line"><span class="function">fileName <span class="title">outputFile</span><span class="params">(db().time().rootPath()/db().time().globalCaseName()/<span class="string">"processors"</span>+nProcs.str()/db().time().timeName()/+<span class="string">"vortons_"</span>+patch().name())</span></span>;	</span><br><span class="line">Info&lt;&lt;<span class="string">"outputFile==="</span>&lt;&lt;outputFile&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="function">fileName <span class="title">outputFile2</span><span class="params">(db().time().rootPath()/db().time().globalCaseName()/<span class="string">"processors"</span>+Foam::name(Pstream::nProcs())/db().time().timeName()/+<span class="string">"vortons_"</span>+patch().name())</span></span>;</span><br><span class="line">Info&lt;&lt;<span class="string">"outputFile2==="</span>&lt;&lt;outputFile2&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>上边的outputFile和outputFile2输出相同。</p><h1 id="未解之谜"><a class="markdownIt-Anchor" href="#未解之谜"></a> 未解之谜</h1><p>输运方程中的源项，我只需要内部场，边界场应该怎么处理呢？内部场给了矩阵的 <code>source()</code>，边界场应该没有参与计算。</p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noopener noreferrer" target="_blank">Yan Zhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://openfoam.top/programmingNote/">https://openfoam.top/programmingNote/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external nofollow noopener noreferrer">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://openfoam.top">OpenFOAM 成长之路</a>！</span></div></div><div class="post-meta__tag-list"></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/album/wechatPay.jpg"><div class="post-qr-code__desc">您的肯定会给我更大动力~</div></div></div><div class="social-share pull-right" data-disabled="tencent,douban,qzone,diandian,facebook,twitter,google"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/turb/"><i class="fa fa-chevron-left"></i><span>OpenFOAM 可压缩湍流库深度解析</span></a></div><div class="next-post pull-right"><a href="/chemistry/"><span>OpenFOAM 燃烧化学求解过程解析</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk=new Gitalk({clientID:"9dfad189aeefc4c2dde2",clientSecret:"69b4d95e0c4be2508135adae20b05bf6f298f386",repo:"zhangyantju.github.io",owner:"ZhangYanTJU",admin:"ZhangYanTJU",id:md5(decodeURI(location.pathname)),language:"zh-CN"});gitalk.render("gitalk-container")</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By Yan Zhang</div><div class="framework-info"><span>驱动 -</span> <a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 -</span> <a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="external nofollow noopener noreferrer"><span>Melody</span></a></div><div class="footer_custom_text">Hosted by <a target="_blank" rel="external nofollow noopener noreferrer" href="https://pages.coding.me"><b>Coding Pages</b></a></div></div><script id="maid-script" src="https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js?v=undefined"></script><script>if(window.mermaid){var options=JSON.parse(document.getElementById("maid-script").getAttribute("mermaidoptioins"));mermaid.initialize(options)}</script></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"),$("#top-container").addClass("is-mobile"))</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>
<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="OpenFOAM 热物理库深度解析"><meta name="keywords" content="thermophysicalModels,RTS"><meta name="author" content="Yan Zhang"><meta name="copyright" content="Yan Zhang"><title>OpenFOAM 热物理库深度解析 | OpenFOAM 成长之路</title><link rel="shortcut icon" href="/album/linktocat.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?38997e7d3b8e8c254bf0ddb7d2452127";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject="ga",e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script"),ga("create","UA-119919860-1","auto"),ga("send","pageview")</script><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容:${query}"}},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"}}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="OpenFOAM 成长之路" type="application/atom+xml"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#of-7"><span class="toc-number">1.</span> <span class="toc-text">OF-7</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#uml-类图"><span class="toc-number">1.1.</span> <span class="toc-text">UML 类图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#求解器中创建对象"><span class="toc-number">2.</span> <span class="toc-text">求解器中创建对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rts-选择热物理模型"><span class="toc-number">3.</span> <span class="toc-text">RTS 选择热物理模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#从字典文件的设置开始"><span class="toc-number">3.1.</span> <span class="toc-text">从字典文件的设置开始</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rts-库的生成"><span class="toc-number">4.</span> <span class="toc-text">RTS 库的生成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#definethermophysicsreactionthermo"><span class="toc-number">4.1.</span> <span class="toc-text">defineThermoPhysicsReactionThermo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#makethermophysicsreactionthermos"><span class="toc-number">4.2.</span> <span class="toc-text">makeThermoPhysicsReactionThermos</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#of-8"><span class="toc-number">5.</span> <span class="toc-text">OF-8</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/album/192.jpg"></div><div class="author-info__name text-center">Yan Zhang</div><div class="author-info__description text-center">OpenFOAM 成长之路</div><div class="follow-button"><a href="https://github.com/ZhangYanTJU" target="_blank" rel="external nofollow noopener noreferrer">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">39</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">30</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">OpenFOAM 成长之路</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i> <span class="pull-right menus"><a class="site-page" href="/">首页</a><a class="site-page" href="/about">关于</a><a class="site-page" href="/subscribe">订阅</a><a class="site-page" href="/en">English</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i> <span>搜索</span></a></span></div><div id="post-info"><div id="post-title">OpenFOAM 热物理库深度解析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2018-03-03<span class="post-meta__separator">|</span><i class="fa fa-calendar-check-o" aria-hidden="true"></i> 更新于 2020-05-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/code/">code</a><div class="post-meta-wordcount"><span>字数总计:</span> <span class="word-count">2.5k</span><span class="post-meta__separator">|</span><span>阅读时长: 10 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本帖描述 OpenFOAM 热物理库的宏观框架。但作者水平有限，有些地方理解还不到位。希望各位指正！</p><a id="more"></a><h1 id="of-7"><a class="markdownIt-Anchor" href="#of-7"></a> OF-7</h1><h2 id="uml-类图"><a class="markdownIt-Anchor" href="#uml-类图"></a> UML 类图</h2><p>下图是热物理库部分类的 UML 类图。欲获取更佳阅读体验，可以右键在新标签页打开该图。</p><details><summary>OF-7 UML</summary><img src="http://www.plantuml.com/plantuml/svg/hHhRZXH5z7s_eWB9P1O6WgypwoQmxh8a88ITI8YQJMrFpNPht-pkcNLTIOWOBah45wCGI3J1I4mG4tq0bFWpEmiy-GlMjRkgkwgxQv0NjkgSEdNkb-fPS7oOfY2DaUCXiBS0yB_DJN0XyQOmGs04CuZNTFlOJfICG0W3nDUf0tsOWClgCeZyIyZRThDDGUmS2hPG0iQJqCcyA4m5mQCENcI0aErGkjr5GBSObDExfDszhDszcEzUMLZWCYrzVcmKxOJ7G8oICNAoqp3jWmqAMs325u0bjh-yryWwlp1nesxS6-fuMJS1Lc8JPAC2Y5FFJERSobG6Of4BIGgnFu8X70zTb0HH7wn-Ce54aFFZZGpRboj0GbagOIpNkmJdPUX7EvizC7IntSd_JXG4KSXnd0YDnoUJ1Eu20b-9LyX6MeLY8YgmXG78pLfNeBpe8Omx5SPSiM2ce_3QX2jnthKp-JeqGb8ZnEasUW_nVnIctfQFLiFCXNwyMxW4Yuoqty-epK4V37TZL3rm_FYox1i4Z_x1tQQClyIWRQ87kvRdW3oXT1Vt4fHDaX0SSWyDhfHqD-qoZJFo7S2uxXNIWZt0ZpFGSQflC5mSW3AjKxk47Z0H19pY1s51ywqobVLLEmASAMfG3LD38psNK3nXfZZ49DqU85HFKBBOwhAzwWok6585Splsg5TK4m2twbhPgdao0DqnPRpNPVJw_IDhYz9Yj3OQoclV2xniKNRf5e5FSnymP4OpR1i60QmvoVp31CUMCe5MKpF8VE5f8yI9ZI3NJCyrS-7giqRD0MHcpgmYP2Q8p7nl6o4aEjQ9ZmzF03qyxQwdlHeuh3-F3RTQ2uSLUDvS515LXDg4xFWm70qJ6APnb6JbQAjYL39dNR4zcP8Isxv41XEZSZ-6SMms2ixfBdGLC9QS2R45KyyvvtsAqn5YN1_DSBOOeR42KXOadGmm2GKXLnpRdVYPjn85SHIYCECuofKw14bjKORx7pHI57UO6si8SR4IoOw3pdffjhGLHVuoW5XzKzxR7hwG9HGqZVmDgeqr3_cZPT7irgcTYFakAMg7p1mVMjJfJ8TPqQ3SWyY2TSHA3NCY6rbdq0lJhjnnCtJ2QVK0qqNNXrl8vuYUfWSgjDSHHnIiQUIDS9kGdTIHKr7EXD2CPB16Xum1CZzrU2fVCfo0sNbsjwVGRC9jGxUYy3ONcAo4Ox36NTHuOlEC9euKm9xMSHKKhSCg67f7nO6o_zVF-q-_FlZXoSldJrxTlJUxyUBWkz-B9CKCZS5KeV_-VJl67GHU0fQ5k6Az99j07uYPqEkgJWdU1YUqcBWJv9XolsZ4djfWuyfYWvrQOJjj9Tom8RjgnSHf6-IJDiYu9bbWip9bSO1NBlb4_G4onnleYt1JdJqFiq1RiRIxT9xILF-y7QTHmu9KIs2fG6je5KGYb0w8yl0EnkDOmIIZ9R700W6xgH7XlSXlheIl_hdx-iRjsM_tzf_Tsdz-_TMVZrxVk3ExUHt7_-oh7myUN9iz-sFsu8QS38kREi11liybLt8ksTTL8_bi33F7NOEEC5YNRdWzcSuOWvleaBkmh3cLth0tDoibEXOSQSpPaUqfgfkOecLJYt6Q5je4mH7NvSYZreB9RcTnOE9z6sLd8nmYR4-nWfgUT3U_pr4-7D39DAYlLvWrp52uBKAejBO9djBHzc73kQTCfXvHZz8pIllSmxaglCzGsGJ2P1SfBr4eCx7SxxCZmZPADrU-NLXQsZVOM-QFwbnfVB6cgrg6aop2hEg1N0Ozi68WYgLaoJwGsm5c6mLXIO8NfiaJHZNlxZzz_FBUbmUthXxSlrLk9x2BdJbVU7Mf4r96C6cdQNQOtVc2fAkRtx_wwH6xdVGdBYin6NXzxGNfLRW1fJQEdPOxEOoVqlwAKoxtVR5s7mprs_H-3jhOyN0g0QDurEBHNLI-olMYbHO8-kuqBdNIjSX3FR86hGqrAdBTzMaLcoLPvOoahN8SKGtoe6piN0jfS69reYJ1teC9LbgCB8WhOoJfDunD33cGbh4LGQfdohfoaOuLlLvTLCzBcNdwC3HipxvRgPiagx3QcbgJQL24bc77GjdamOazlBunnnAfERXUYIsuPbyOvhfcQdFDTDvhsCDh-vl4G-ryCiLMGiNJ-IzY3yOsbuadvhakl6GNgcnoQiyTVn2qvuiUN1sFkzeKOya0eSFgwpmgeYSB4ktlBXtKt9qFW-KFB6D_uer4Yu6xi0IbzDDOtgQUYqQuKQGjae9Bsn5fPwzr_TQ97axqvR4YAaQiLiQvAjv5DzBR7621CuZ1hUiG-TXjPUbWOk7QmKJZrzYUalAbtmgadcAXVDtKBfQwD7nkSw2511CEmBGabs8jfgpzsVr71uyVifwubHD8lOLjNo4OadHYoP2bQmmi_SB69opzWVv-GfXPyGGnmfKzGjtVQnL3WftgQ8Ex2sN0m-uvK8umvJGVpBsRV6jPM32yMxae_wWl3saLiRGdJbKcAW5Saa0ze1tlsaMEYuhuQCw5-0BoEmBvmdw__23TKVGaUluZcUkb-IE9ekjvoAe3XPOu_Ta3-sxuhlIh9t56kIpBNmtmt-9zVh4OKIgfO_RmbzVN7irkNhS8sUeu87WXLhXYDqFK76qS9fedW8OneWq1pKXOos3UFmrQ8RUN1hwfD70EQPoMwP7EBgXn2cfD1O06JilZZBLeAt5BqV0GOqzyshu4AQDEgp6daPtAl3A7TYmaA8qrBKSQQvukjUT86MJiXvZ_QO2n75w09G_woSLoQW6LhYOlt58flr1gSAKTLiBpfR6AD_mQZ7M2q7ScFiRZBtowYdLm_-hiss_sdrxTV_hhN7qcfdtbFm00"></details><h1 id="求解器中创建对象"><a class="markdownIt-Anchor" href="#求解器中创建对象"></a> 求解器中创建对象</h1><p><code>solver</code> 中的 <code>creatFields.H</code> 中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">autoPtr&lt;psiReactionThermo&gt; pThermo(psiReactionThermo::New(mesh));</span><br><span class="line">psiReactionThermo&amp; thermo &#x3D; pThermo();</span><br></pre></td></tr></table></figure><p>创建 <code>thermo</code>，在 <code>reactingFoam</code> 自带算例中，创建的是 <code>hePsiThermo</code> 的对象，但是这里 thermo 是基类 <code>psiReactionThermo</code> 的引用，即只能使用 <code>psiReactionThermo</code> 这一继承链的方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">basicSpecieMixture&amp; composition &#x3D; thermo.composition();</span><br></pre></td></tr></table></figure><p>创建 <code>composition</code>，是指系统中的混合物。可以调用继承链中 <code>mixture</code> 这一分支的方法。</p><p>燃烧类的求解器中，一般都没有对单个组分进行操作，这些操作都在热物理库里边进行。</p><p><code>multiComponentMixture</code> 类中的私有数据 <code>speciesData_</code> 的类型是 <code>PtrList&lt;sutherlandTransport&lt;species::thermo&lt;janafThermo&lt;perfectGas&lt;specie&gt;&gt;,sensibleEnthalpy&gt;&gt;&gt;</code>，它是组分的 <code>list</code>，可以用它获取组分的所有信息。solver 中可以通过 <code>multiComponentMixture</code> （<code>solver</code> 中<code>composition</code> 的类型是 <code>basicSpecieMixture</code>，需要强制转换成 <code>multiComponentMixture</code> 才行 ） 的 <code>speciesData()</code> 或者 <code>getLocalThermo(speciei)</code> 这两个函数来调用。如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dynamic_cast&lt;const multiComponentMixture&lt;gasHThermoPhysics&gt;&amp;&gt;(composition).speciesData()[speciei].rho(p,T)</span><br></pre></td></tr></table></figure><p>也可以通过 <code>multiComponentMixture</code> 的派生类 <code>reactingMixture</code> 来调用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dynamic_cast&lt;const reactingMixture&lt;gasHThermoPhysics&gt;&amp;&gt;(composition).speciesData()[speciei].rho(p,T)</span><br></pre></td></tr></table></figure><p>也可以通过派生类的派生类 <code>SpecieMixture</code> 来调用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dynamic_cast&lt;const SpecieMixture&lt;reactingMixture&lt;gasHThermoPhysics&gt;&gt;&amp;&gt;(composition).speciesData()[speciei].rho(p,T)</span><br></pre></td></tr></table></figure><p>上述操作说明可以使用组分列表调用单个组分的函数（即 <code>sutherlandTransport&lt;species::thermo&lt;janafThermo&lt;perfectGas&lt;specie&gt;&gt;,sensibleEnthalpy&gt;&gt;</code> 继承链中的任何函数），如 <code>speciesData_[i].rho(p, T)</code>，这里的 <code>rho(p,T)</code> 来自于 <code>perfectGas</code> 类。</p><p>也可以在求解器中重新构造组分列表：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">autoPtr&lt;psiReactionThermo&gt; <span class="title">pThermo</span><span class="params">(psiReactionThermo::New(mesh))</span></span>;</span><br><span class="line">psiReactionThermo&amp; thermo = pThermo();</span><br><span class="line"></span><br><span class="line">basicSpecieMixture&amp; composition = thermo.composition();</span><br><span class="line">PtrList&lt;volScalarField&gt;&amp; Y = composition.Y();</span><br><span class="line"></span><br><span class="line"><span class="function">PtrList&lt;gasHThermoPhysics&gt; <span class="title">specieData</span><span class="params">(Y.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">forAll(specieData, i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//对于每个组分，通过 thermo 调用 Lib 中的 speciesData_ 来构造 solver 中的 specieData</span></span><br><span class="line">    specieData.<span class="built_in">set</span></span><br><span class="line">    (</span><br><span class="line">        i,</span><br><span class="line">        <span class="keyword">new</span> gasHThermoPhysics</span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> reactingMixture&lt;gasHThermoPhysics&gt;&amp;&gt;</span><br><span class="line">                (thermo).speciesData()[i]</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个网格构造一个 mixture,这个 mixture 相当于 multiComponentMixture 中的私有数据 mixture_。</span></span><br><span class="line"><span class="comment">// 它是混合物等效成的一个组分，和单个组分同一类型，即 `gasHThermoPhysics`。</span></span><br><span class="line">forAll(T, celli)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">gasHThermoPhysics <span class="title">mixture</span><span class="params">(<span class="number">0.</span>*specieData[<span class="number">0</span>])</span></span>;</span><br><span class="line">    forAll(Y, speciei)</span><br><span class="line">    &#123;</span><br><span class="line">        mixture += Y[speciei][celli]*specieData[speciei];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gasHThermoPhysics</code> 是 <code>sutherlandTransport&lt;species::thermo&lt;janafThermo&lt;perfectGas&lt;specie&gt;&gt;,sensibleEnthalpy&gt;&gt;</code> 的别名，它是单个组分的类型。<br>事实上，<code>multiComponentMixture</code> 类中的函数 <code>cellMixture</code> 函数可以用于获取 <code>mixture_</code>。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ThermoType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">const</span> <span class="title">ThermoType</span>&amp; <span class="title">Foam</span>:</span>:multiComponentMixture&lt;ThermoType&gt;::cellMixture</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> label celli</span><br><span class="line">) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    mixture_ = Y_[<span class="number">0</span>][celli]*speciesData_[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (label n=<span class="number">1</span>; n&lt;Y_.<span class="built_in">size</span>(); n++)</span><br><span class="line">    &#123;</span><br><span class="line">        mixture_ += Y_[n][celli]*speciesData_[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mixture_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法参考 hePsiThermo.C</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scalarField&amp; hCells = <span class="keyword">this</span>-&gt;he_;</span><br><span class="line"><span class="keyword">const</span> scalarField&amp; pCells = <span class="keyword">this</span>-&gt;p_;</span><br><span class="line"></span><br><span class="line">scalarField&amp; TCells = <span class="keyword">this</span>-&gt;T_.primitiveFieldRef();</span><br><span class="line">scalarField&amp; psiCells = <span class="keyword">this</span>-&gt;psi_.primitiveFieldRef();</span><br><span class="line">scalarField&amp; muCells = <span class="keyword">this</span>-&gt;mu_.primitiveFieldRef();</span><br><span class="line">scalarField&amp; alphaCells = <span class="keyword">this</span>-&gt;alpha_.primitiveFieldRef();</span><br><span class="line"></span><br><span class="line">forAll(TCells, celli)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> MixtureType::thermoType&amp; mixture_ =</span><br><span class="line">        <span class="keyword">this</span>-&gt;cellMixture(celli);</span><br><span class="line"></span><br><span class="line">    TCells[celli] = mixture_.THE</span><br><span class="line">    (</span><br><span class="line">        hCells[celli],</span><br><span class="line">        pCells[celli],</span><br><span class="line">        TCells[celli]</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    psiCells[celli] = mixture_.psi(pCells[celli], TCells[celli]);</span><br><span class="line"></span><br><span class="line">    muCells[celli] = mixture_.mu(pCells[celli], TCells[celli]);</span><br><span class="line">    alphaCells[celli] = mixture_.alphah(pCells[celli], TCells[celli]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rts-选择热物理模型"><a class="markdownIt-Anchor" href="#rts-选择热物理模型"></a> RTS 选择热物理模型</h1><h2 id="从字典文件的设置开始"><a class="markdownIt-Anchor" href="#从字典文件的设置开始"></a> 从字典文件的设置开始</h2><p>下面介绍我们是如何从 <code>thermophysicalProperties</code> 字典文件中的下列设置构建对象的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thermoType</span><br><span class="line">&#123;</span><br><span class="line">    type            hePsiThermo;</span><br><span class="line">    mixture         reactingMixture;</span><br><span class="line">    transport       sutherland;</span><br><span class="line">    thermo          janaf;</span><br><span class="line">    energy          sensibleEnthalpy;</span><br><span class="line">    equationOfState perfectGas;</span><br><span class="line">    specie          specie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>solver 中创建模型：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">autoPtr&lt;psiReactionThermo&gt; pThermo(psiReactionThermo::New(mesh));</span><br></pre></td></tr></table></figure><p>这个函数定义于 psiReactionThermo：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Foam::autoPtr&lt;Foam::psiReactionThermo&gt; Foam::psiReactionThermo::New</span><br><span class="line">(</span><br><span class="line">    const fvMesh&amp; mesh,</span><br><span class="line">    const word&amp; phaseName</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    return basicThermo::New&lt;psiReactionThermo&gt;(mesh, phaseName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它调用了basicThermo 中的 New 函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Thermo</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Foam</span>:</span>:autoPtr&lt;Thermo&gt; Foam::basicThermo::New(<span class="keyword">const</span> fvMesh&amp; mesh,<span class="keyword">const</span> <span class="keyword">word</span>&amp; phaseName)</span><br><span class="line">&#123;</span><br><span class="line">    thermoDict---thermophysicalProperties</span><br><span class="line">    <span class="keyword">typename</span> Thermo::fvMeshConstructorTable::iterator cstrIter =</span><br><span class="line">        lookupThermo&lt;Thermo, <span class="keyword">typename</span> Thermo::fvMeshConstructorTable&gt;</span><br><span class="line">        (</span><br><span class="line">            thermoDict,</span><br><span class="line">            Thermo::fvMeshConstructorTablePtr_</span><br><span class="line">        );</span><br><span class="line"><span class="comment">//fvMeshConstructorTablePtr_</span></span><br><span class="line"><span class="comment">//这个是在 runTimeSelectionTables.H 的 declareRunTimeSelectionTable 函数中定义的。</span></span><br><span class="line">    <span class="keyword">return</span> autoPtr&lt;Thermo&gt;(cstrIter()(mesh, phaseName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了 2 参数的 lookupThermo：<br><a href="https://cpp.openfoam.org/v3/a09872_source.html" target="_blank" rel="external nofollow noopener noreferrer">basicThermoTemplates.C</a> 中的 <code>lookupThermo</code> 函数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class Thermo, class Table&gt;</span><br><span class="line">typename Table::iterator Foam::basicThermo::lookupThermo</span><br><span class="line">(</span><br><span class="line">    const dictionary&amp; thermoDict,</span><br><span class="line">    Table* tablePtr    &#x2F;&#x2F;即 fvMeshConstructorTablePtr_，它是哈希表add类型的一个指针，typeName和模型都存放在这里</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    const word thermoTypeName</span><br><span class="line">    (</span><br><span class="line">    word(thermoTypeDict.lookup(&quot;type&quot;)) + &#39;&lt;&#39;</span><br><span class="line">    + word(thermoTypeDict.lookup(&quot;mixture&quot;)) + &#39;&lt;&#39;</span><br><span class="line">    + word(thermoTypeDict.lookup(&quot;transport&quot;)) + &#39;&lt;&#39;</span><br><span class="line">    + word(thermoTypeDict.lookup(&quot;thermo&quot;)) + &#39;&lt;&#39;</span><br><span class="line">    + word(thermoTypeDict.lookup(&quot;equationOfState&quot;)) + &#39;&lt;&#39;</span><br><span class="line">    + word(thermoTypeDict.lookup(&quot;specie&quot;)) + &quot;&gt;&gt;,&quot;</span><br><span class="line">    + word(thermoTypeDict.lookup(&quot;energy&quot;)) + &quot;&gt;&gt;&gt;&quot;</span><br><span class="line">    );</span><br><span class="line">&#x2F;&#x2F;通过字典文件读入的数据，构造 thermoTypeName: &#x2F;&#x2F;hePsiThermo&lt;reactingMixture&lt;sutherland&lt;janaf&lt;perfectGas&lt;specie&gt;&gt;,sensibleEnthalpy&gt;&gt;&gt;</span><br><span class="line">&#x2F;&#x2F;注意这里并不是类名，而是省略版</span><br><span class="line"></span><br><span class="line">    return lookupThermo&lt;Thermo, Table&gt;</span><br><span class="line">    (</span><br><span class="line">    thermoTypeDict,</span><br><span class="line">    tablePtr,</span><br><span class="line">    nCmpt,</span><br><span class="line">    cmptNames,</span><br><span class="line">    thermoTypeName</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后返回值是调用 5 个参数的 <code>lookupThermo</code> 函数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class Thermo, class Table&gt;</span><br><span class="line">typename Table::iterator Foam::basicThermo::lookupThermo</span><br><span class="line">(</span><br><span class="line">    const dictionary&amp; thermoTypeDict,</span><br><span class="line">    Table* tablePtr,</span><br><span class="line">    const int nCmpt,</span><br><span class="line">    const char* cmptNames[],</span><br><span class="line">    const word&amp; thermoTypeName</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Lookup the thermo package</span><br><span class="line">    typename Table::iterator cstrIter &#x3D; tablePtr-&gt;find(thermoTypeName);</span><br><span class="line">    return cstrIter;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;上述步骤是根据字典文件在备选库中选择我们需要的组合，那么备选库是怎么形成的呢？</span><br></pre></td></tr></table></figure><p>第一个 <code>lookupThermo</code> 函数的作用是，将 <code>thermophysicalProperties</code> 字典文件中的设置翻译成：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hePsiThermo&lt;reactingMixture&lt;sutherland&lt;janaf&lt;perfectGas&lt;specie&gt;&gt;,sensibleEnthalpy&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>但该字符串并不是最终的 <code>class</code>，比如 <code>janaf</code>，实际上类名是 <code>janafThermo</code>。</p><p>第二个 <code>lookupThermo</code> 函数的作用就是，根据该字符串，在 <code>RTS</code> 库中找到我们选择的类。<br>那么上面提到的省略版字符串，怎么和 <code>RTS</code> 库中的组合匹配的呢？下面来看 <code>RTS</code> 库的生成过程。</p><h1 id="rts-库的生成"><a class="markdownIt-Anchor" href="#rts-库的生成"></a> RTS 库的生成</h1><p>按照<a href="http://xiaopingqiu.github.io/2016/03/12/RTS1/" target="_blank" rel="external nofollow noopener noreferrer">Giskard 博客</a>提到的 <code>RTS</code> 流程：</p><blockquote><ol><li>基类类体里调用 <code>TypeName</code> 和 <code>declareRunTimeSelectionTable</code> 两个函数，类体外面调用 <code>defineTypeNameAndDebug</code> 和 <code>defineRunTimeSelectionTable</code> 两个函数。</li><li>基类中需要一个静态 <code>New</code> 函数作为 <code>selector</code>。</li><li>派生类类体中需要调用 <code>TypeName</code> 函数，类体外调用 <code>defineRunTimeSelectionTable</code> 和 <code>addToRunTimeSelectionTable</code> 两个宏函数。</li></ol></blockquote><p>我们发现：<code>makeReactionThermo.H</code> 中有两个重要函数：<code>defineThermoPhysicsReactionThermo</code> 和 <code>makeThermoPhysicsReactionThermos</code>。</p><p>下面一一介绍：</p><h2 id="definethermophysicsreactionthermo"><a class="markdownIt-Anchor" href="#definethermophysicsreactionthermo"></a> defineThermoPhysicsReactionThermo</h2><p>其中的 <code>defineThermoPhysicsReactionThermo</code>, 这个函数通过一组形参列表得到 <code>CThermo##Mixture##ThermoPhys</code>，然后再转换成一串简化的字符串。这里的形参列表就是实例化所需要提供的各种类，对应<code>(psiReactionThermo,hePsiThermo,reactingMixture,sutherlandTransport)</code>。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> defineThermoPhysicsReactionThermo(BaseReactionThermo,CThermo,Mixture,ThermoPhys) \</span></span><br><span class="line">    <span class="keyword">typedef</span> CThermo<span class="comment">//hePsiThermo                                                         \</span></span><br><span class="line">    &lt;                                                                                    \</span><br><span class="line">        BaseReactionThermo,<span class="comment">//psiReactionThermo                                           \</span></span><br><span class="line">        SpecieMixture                                                                    \</span><br><span class="line">        &lt;                                                                                \</span><br><span class="line">            Mixture<span class="comment">//reactingMixture                                                     \</span></span><br><span class="line">            &lt;                                                                            \</span><br><span class="line">                ThermoPhys<span class="comment">//sutherlandTransport                                          \</span></span><br><span class="line">            &gt;                                                                            \</span><br><span class="line">        &gt;                                                                                \</span><br><span class="line">    &gt; CThermo##Mixture##ThermoPhys;                                                      \</span><br><span class="line">                                                                                         \</span><br><span class="line">    defineTemplateTypeNameAndDebugWithName                                               \</span><br><span class="line">    (                                                                                    \</span><br><span class="line">        CThermo##Mixture##ThermoPhys,                                                    \</span><br><span class="line">        (#CThermo<span class="string">"&lt;"</span> + Mixture&lt;ThermoPhys&gt;::typeName() + <span class="string">"&gt;"</span>).c_str(),                   \</span><br><span class="line">        <span class="number">0</span>                                                                                \</span><br><span class="line">    )</span><br><span class="line"><span class="comment">//作用：把尖括号表示的类变成字符串 CThermo##Mixture##ThermoPhys，然后再变成简化的尖括号。</span></span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hePsiThermo</span><br><span class="line">&lt;</span><br><span class="line">psiReactionThermo,</span><br><span class="line">    SpecieMixture</span><br><span class="line">    &lt;</span><br><span class="line">        reactingMixture</span><br><span class="line">        &lt;</span><br><span class="line">            sutherlandTransport</span><br><span class="line">            &lt;</span><br><span class="line">                species::thermo</span><br><span class="line">                &lt;</span><br><span class="line">                    janafThermo&lt;perfectGas&lt;specie&gt;&gt;,sensibleEnthalpy</span><br><span class="line">                &gt;</span><br><span class="line">            &gt;</span><br><span class="line">        &gt;</span><br><span class="line">    &gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>变成 <code>RTS</code> 库中保存的字符串：<br><code>hePsiThermo&lt;reactingMixture&lt;sutherland&lt;janaf&lt;perfectGas&lt;specie&gt;&gt;,sensibleEnthalpy&gt;&gt;&gt;</code><br>隐藏了一些信息，如 <code>psiReactionThermo</code>和 <code>SpecieMixture</code> 。</p><p>具体过程：<br><code>typeName()</code> 依次调用 <code>reactingMixture</code>，<code>sutherlandTransport</code>, <code>species::thermo</code>, <code>janafThermo</code>, <code>sensibleEnthalpy</code>, <code>perfectGas</code>, <code>specie</code> 的 <code>typeName()</code>。返回值依次是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;reactingMixture&lt;&quot; + ThermoType::typeName() + &#39;&gt;&#39;</span><br><span class="line">sutherland&lt;&quot; + Thermo::typeName() + &#39;&gt;&#39;</span><br><span class="line">Thermo::typeName() + &#39;,&#39; + Type&lt;thermo&lt;Thermo, Type&gt;&gt;::typeName()</span><br><span class="line">&quot;janaf&lt;&quot; + EquationOfState::typeName() + &#39;&gt;&#39;</span><br><span class="line">&quot;sensibleEnthalpy&quot;</span><br><span class="line">&quot;perfectGas&lt;&quot; + word(Specie::typeName_()) + &#39;&gt;&#39;</span><br></pre></td></tr></table></figure><p>最底层的 <code>specie</code> 类只有一个 <code>ClassName(&quot;specie&quot;)</code>;<br>我们找到一个文件<code>className.H</code> 中：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ClassName(TypeNameString)                             \</span></span><br><span class="line">	ClassNameNoDebug(TypeNameString);                         \</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> debug</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ClassNameNoDebug(TypeNameString)                      \</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">typeName_</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> TypeNameString; &#125; \</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> ::Foam::<span class="keyword">word</span> typeName</span><br></pre></td></tr></table></figure><p>所以这里的意义就在于用简化版的字符串表示完整的类型。而简化版的字符串则是读取 thermophysicalProperties 之后稍作处理得到的。（在前面的2 参数的 lookupThermo 中）</p><h2 id="makethermophysicsreactionthermos"><a class="markdownIt-Anchor" href="#makethermophysicsreactionthermos"></a> makeThermoPhysicsReactionThermos</h2><p>定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> makeThermoPhysicsReactionThermos(BaseThermo,BaseReactionThermo,CThermo,Mixture,ThermoPhys)</span></span><br><span class="line"><span class="comment">// 定义于 makeReactionThermo.H</span></span><br><span class="line">    defineThermoPhysicsReactionThermo(BaseReactionThermo,CThermo,Mixture,ThermoPhys);</span><br><span class="line"></span><br><span class="line">    addThermoPhysicsThermo(basicThermo, CThermo##Mixture##ThermoPhys);</span><br><span class="line">    addThermoPhysicsThermo(fluidThermo, CThermo##Mixture##ThermoPhys);</span><br><span class="line">    addThermoPhysicsThermo(BaseThermo, CThermo##Mixture##ThermoPhys);</span><br><span class="line">    addThermoPhysicsThermo(BaseReactionThermo, CThermo##Mixture##ThermoPhys)</span><br></pre></td></tr></table></figure><p>调用了上边的 <code>defineThermoPhysicsReactionThermo</code> 用于创建 <code>RTS</code> 中的 <code>typeName</code>，调用了 <code>addThermoPhysicsThermo</code>（位于 <code>makeThermo.H</code>）, 用于写入到 <code>RTS</code> 哈希表。<br><code>makeThermoPhysicsReactionThermos</code> 函数的形参：<code>(BaseThermo,BaseReactionThermo,CThermo,Mixture,ThermoPhys)</code>，这是实例化需要提供的所有信息。<br>比如其中的一种组合：<code>makeThermoPhysicsReactionThermos(psiThermo,psiReactionThermo,hePsiThermo,reactingMixture,gasHThermoPhysics)</code>（所有的组合在 <a href="https://github.com/OpenFOAM/OpenFOAM-dev/blob/master/src/thermophysicalModels/reactionThermo/psiReactionThermo/psiReactionThermos.C" target="_blank" rel="external nofollow noopener noreferrer"><code>psiReactionThermos.C</code></a> 中列出）。</p><p>这里调用 4 个 addThermoPhysicsThermo 函数是为何？假定先分析第一个 addThermoPhysicsThermo 函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> addThermoPhysicsThermo(BaseThermo_,CThermoMixtureThermoPhys_) <span class="comment">//定义于makeThermo.H</span></span></span><br><span class="line">    addToRunTimeSelectionTable</span><br><span class="line">    (</span><br><span class="line">        BaseThermo_,<span class="comment">//基类名</span></span><br><span class="line">        CThermoMixtureThermoPhys_,<span class="comment">//派生类名</span></span><br><span class="line">        fvMesh</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p><code>BaseThermo_</code> 是 <code>basicThermo</code>，<code>CThermoMixtureThermoPhys_</code> 是<code>hePsiThermo##reactingMixture##gasHThermoPhysics</code>。</p><p>这里的 <code>addToRunTimeSelectionTable</code> 函数定义于 <code>addToRunTimeSelectionTable.H</code> 中：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> addToRunTimeSelectionTable(baseType,thisType,argNames)</span></span><br><span class="line">    baseType::add##argNames##ConstructorToTable&lt;thisType&gt;</span><br><span class="line">        add##thisType##argNames##ConstructorTo##baseType##Table_</span><br></pre></td></tr></table></figure><p><code>addfvMeshConstructorToTable</code> 这个类是在 <code>runTimeSelectionTables.H</code> 文件中的 <code>declareRunTimeSelectionTable</code> 宏函数中定义的。</p><p>所以 <code>addThermoPhysicsThermo</code> 中创建了一个 <code>baseType::addfvMeshConstructorToTable&lt;thisType&gt;</code> 类的对象 <code>add##thisType##fvMesh##ConstructorTo##baseType##Table_</code>，而该对象构造时会往哈希表中插入键和值，即派生类的名字和 New 函数，此函数返回指向派生类对象的基类指针。<br>这里的基类 <code>baseType</code> 是 <code>basicThermo</code>，派生类 <code>thisType</code> 是 <code>hePsiThermo##reactingMixture##gasHThermoPhysics</code>，这里是省略版。</p><h1 id="of-8"><a class="markdownIt-Anchor" href="#of-8"></a> OF-8</h1><p>OF-8 去除了 <code>reactingMixture</code> 这个类！<br>它的成员 <code>speciesComposition_</code> 移至 <code>multiComponentMixture</code> 中。<br>另外 <code>multiComponentMixture</code> 还新增了 <code>readSpeciesData</code> 和 <code>readSpeciesComposition</code> 这两个函数，用于初始化 <code>specieThermos_</code> 和 <code>speciesComposition_</code>。</p><p>之前（OF-7）化学反应的信息是保存在 <code>reactingMixture</code> 中，然后复制到 <code>StandardChemistryModel</code>中的 <code>reactions_</code><br>现在（OF-8）是直接保存在 <code>StandardChemistryModel</code> 中的 <code>reactions_</code>。</p><p>化学反应的信息在 <code>StandardChemistryModel</code> 中，以前（OF-7）是</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PtrList&lt;Reaction&lt;ThermoType&gt;&gt;&amp; reactions_;</span><br></pre></td></tr></table></figure><p>以前（OF-7）是下面这样，调用的是复制构造函数，因为所有的化学反应的信息都包含在 <code>reactingMixture</code> 中！</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">reactions_</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> reactingMixture&lt;ThermoType&gt;&amp;&gt;(<span class="keyword">this</span>-&gt;thermo())</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>现在（OF-8）是</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactionList&lt;ThermoType&gt; reactions_;</span><br></pre></td></tr></table></figure><p>现在在 <code>StandardChemistryModel</code> 中是这样构造：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">reactions_</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> multiComponentMixture&lt;ThermoType&gt;&amp;&gt;</span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">this</span>-&gt;thermo()</span><br><span class="line">    ).species(),</span><br><span class="line">    specieThermo_,</span><br><span class="line">    <span class="keyword">this</span>-&gt;mesh(),</span><br><span class="line">    *<span class="keyword">this</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>调用的是这个构造函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//- Construct from thermo list, objectRegistry and dictionary</span></span><br><span class="line">ReactionList</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> speciesTable&amp; species,</span><br><span class="line">    <span class="keyword">const</span> PtrList&lt;ThermoType&gt;&amp; speciesThermo,</span><br><span class="line">    <span class="keyword">const</span> objectRegistry&amp; ob,</span><br><span class="line">    <span class="keyword">const</span> dictionary&amp; dict</span><br><span class="line">);basicThermo</span><br></pre></td></tr></table></figure><p>下图是热物理库部分类的 UML 类图。欲获取更佳阅读体验，可以右键在新标签页打开该图。</p><details><summary>OF-8 UML</summary><img src="http://www.plantuml.com/plantuml/svg/nHhRRjp6zTdvYa4222jtPTXvAR1I1TYoP3ckQyDQL4Wl44Rah3WnR-KCrnPS0qPT-D86JL-ADeO3j42A6WNI56WVdBH1VqQhs4_zXSw5NCuCXrmELq3z82zvpfmpvphdd240m0iX8O2aoCC8F7W7o7y71-1sXgUG8k132jbp2LcxbsG-Y664gbV4Wo7Cm8UrDr4IxYDy5D03XV1D51sY34posACuYOb2_3iUUwQ0irWHF0QhGBoQ8nI4zvi07pO1xgY0X_nF8VF6pzVyv5wy1bAKJP17hq4o0di2nh6aVYhOXWHjFkWe4Q6GOa-o1eT94W8SUqcKPeWGV1WYy3qmWI51RGj8uWL9nbxMSALiMP0CqY4ODuY-smRSIjkWswrBfmFG0jvB1rA8ufcXQi-DwwRzrgK4j-tsH-rQkCcaCH24brIMhppb8nZ3oJX0MPICmFRFSiYjVckonood-8o2jM4WQTvpEpyCcMsDEDFz0CSKn5i9cap80VE2xywnw76AV3G1E_W-yh-F2TsG4Wtdw9kC1FjnESlWSOVmBfKS9lSEc3e25htyV-QoKH9NQ1LDm56sqeAR3O6Hgi5RTZ1Di0-y07bthyTfJgyoi1dKQr8h5OyL-PiCJ0ClYaufROWZJ0TDpi5rqPHMX88QWL9hDN1zzweEEw0h6Ysn2Of5FjcEQG33zDWjpdTXAvIqGYTDyk-rBRj6g6yprrKa_09F4Q0iTa1Ea0ycIGO-W5voY65iiP-_bVfZQ_YQQgc2MAP_CXfH4Q9W1COibgnhBbpOLAEPeueVLQoRIpOaWkif8SvM5AFiwFW7ulHxa26QPp5uDtXt_Q4LEsx3AqrVPbIvgnKWHHwgsVidCNW02YeIVA5qcNLW8Ndbc9C5pNI1XV0b2wdTRLSgnVPAhxJG73SJ3IJTYyrqnupm7AiWBlweBj3cHgPlw1Y5Qmo5kstQAgwhPagMvgP9M7jNdGuHl7-TnOijmHQEjsDnl7cw1uF9C1sEBmu7SfUZqVcTLUN1t_77whF8cAj3fKhnCJoA4y9sHSewnJ4NIv5m7E8OIUSEa0o34aTnQ4jcAQ17C8fW2xpqtMQCtUqMuBKMsEKMc9Us08Es3GUa3UYLsNVTWBGcxG2rGRrf6nIrKaQjHybHYoZMXSnfMF64GtoOuJnYeGg5vnJ1wX-p_CSzhlAZWjYD5aOtsannmsi3tcT04rPuR8aISvHXR9539FQrJOeYLbL2bdCGNpn56U4IjHKeFA7j5Za9D5KRB6_jaeL8S36XRJBONeW36t6M4zM_uVdZmsEx6UP8NkE1R-JZAb7d_4q8Ot-SmPYaIKOjkRgEP3lA5nJFbmalcHsANHXwHJKNvPVOqal3A7-V_V_-gacQ-RylK0TggongGvugorR9nqA_C6F58l-zwbOFHtcRyk_2D6qDSbO11J2mckSG4kpTnFU5Hynj8zxAnhg0LIQfmtHB99IrPwn4D3JxNk48OyYRxEAXWefMYPzRcu0db6arpNZlDiq4T9g4UqAU7On2VrCPRtGQOgZyLygdMgKiZaxsYa8S4yscSWKtgdMDtFL0Oc5xor09kLBYcuZ2_mYYbtLoDVZr63PWDAXhXOzYZFsqeTRsfQ9m34aYX8Se1DYal0Yz8_MQvZkoMM0nvYyd__hpoUjVd_xXos-__lBDfozcJxyv_TtVjSYJUcKOOi___VV7AQlAs6DnhbHxnndDOLWUD_lOy05MV5riGcQjMdTaFbKgiBLEmRg6HcajO9m8L6tgKZnTrbVLdXDBel9pNMpkrsLzrOqliL-ov7w9-txXClk5I-uNEk-N7NvBiNHPhvseIt5r9A6VrFeoDyPM4ZhdwkJNpl7g_8_oaEAj94gJ6CLKAG6i036FiLHgyzwx7EJ80i9AOwF2x5JPbKUNigp8z_8DAotEhPN3s5r80d7kRyY9hC3R3b74-6-MwuZO4i6yV138Z403nBAYsbcKKu5JxGn4KiOkE3_aGuLpzM61LjYSiuhFIr5fJo9cjFNAKvRWLtdzMHo8pI8gr1HOAz5XIw4bdWxCiR6ijfCiOoNZJUOREvdi9bbT9fImkAgpA695TuIob2b7ShgNh3zyvvnU89gQACcfMh2IrDn1cVgz-S-dRvz-FFlRYvEldfzy_UJDFr-zVVh9xDaJLd3CVlN7qyyUpxxwn-opfuPWbK2idK1XMCI9LaVnzmsbfheyXTGBTg1Nnlb0lC1bRo9fJHYy0otEalded19BBZeTrptLY7NT77EFEyn75LzKlKDu5lVXkiUkQXIKIIDFYQnnOVqmZdrql-vigW2g6nb5dDtJVbmW_NIzc63QSodBmMj0IyiZKFpGqwY6iw6WQFbpxdQsV7_o-ejlN_pozFcZqvVFc-hW1SMTK_6mfTz05aNxtEOAhVLk_AUE_ATT-JiSyKuxA5fr6plX5TTlAUwij-FcQ4HvsQq1dtto2vvodlt-pPzUISi3tj84icAWuEtZRtXxKzVGd8BQNB4bHFHM5GDTFs3S214CA-ZUFSpq0VpKfmTMILe6vhNMCKoIktbwAzlYUyroZnOcdqnl8XAiW8ZzBPEB5y3ilBYnCHCMbv6VAo10Lv8yzfavU6WHfOMse5nXAZ7GNBv642DsRd-krdNhxPBGEbDCYZ8ghwJCBpI6m6gb-OtKzLl9uKTChQFHKPRagQ0XrrMuok7LaQkH-HJV78tggmr-1wlrkxJY8gEYKrgsoBYbKM_pKD8S89siMdKdR4NI45D9eYO7dRyUQhVyKKfNw_b8BLrO3h15lz1THNLWpM-MJr3Q4CjFJ-muIYIPDOg8BaNFYmO52vCnCLTqIE9ci0QeGNNsyKw01guvMhzNwPQa0qjTmxr7LZ-a7wt5HqnDMkAc7EAk7D93EUGCbKFwAmUwAGUwAmVsK0uyG-N0pignRjzpgqpuZLPvotuc-zS9BXPYN9yvDzX-h9p2ProUBgFn7jNeKknILtxfiWpbFRqZq_9oVpnSpDOUlA9SRFGEIqKl5sZi_Wy5VST97N9ZM2vgiMGrtZC_Zfc4EVRDHa9vQMya16Toq5JEivAhwqrSKqIdbeYs-aBQaYIgUknEK1Q89YCVXHGoiClPmRzZTJMj_ER5oR3LPp9z0tJVZU5-JxUDSZS-_FAw5wCu7xH5Bp5mUyRxzcJI8-JvgcLi9S9uU_xPW3NbKVV4K56i9qJQbYwK9A1yWK-mcIpchxhD78p6dwq-M6y2Hda5OqIL12Qd5Ug4QlRorUaNdylXLjTfbTBLz6Xeb9qfkdBVcMEUMdTFKev1x1x0rRVufJDeBdEd-2JCuZeww46DTNr6oR-bKUVkrhPI6HQqBjOxKo52mmLOWEQV5Xl3rveKraLNR1Ex4hwXG8UWQNBRuMjHuKiunbIRDtMEnW1fmOXzPPIr9JsKwwtUXQyw7lVy7exFV5HPHoFrqoCnKzUCLSujpjC04ylSGjgo3sLzBcBGjoMUsUT_UVlurUpP4xSuhyykIfvSyG-TPnxjgnSFFpeDAnRrhbs9k1_6GVrZB8VXHQTXGwTzMHQvQyGoJ32_2dOOFdGQ5fo1vM1FotdTpn8n5K0TXWnkf1pDoZhzNf9kfTqbPUszqV8wJX7S6uskJSQuXyAcVJNc9eynPEW-OEYrk_tkVFQrc_SbPmkzvWfzPWhTvmbd85rZE-CcDITZRLZS6YkjXN9ednfPYpDtNkCfLT_jUfkal9JLtlnngOAl-Zmz3ncgLlQf0v_YOl_bezblVtFo-j79wx_sRL4aYuV_0m00"></details></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noopener noreferrer" target="_blank">Yan Zhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://openfoam.top/thermodynamicLIB/">https://openfoam.top/thermodynamicLIB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external nofollow noopener noreferrer">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://openfoam.top">OpenFOAM 成长之路</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/thermophysicalModels/">thermophysicalModels</a><a class="post-meta__tags" href="/tags/RTS/">RTS</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/album/wechatPay.jpg"><div class="post-qr-code__desc">您的肯定会给我更大动力~</div></div></div><div class="social-share pull-right" data-disabled="tencent,douban,qzone,diandian,facebook,twitter,google"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/qtcreator/"><i class="fa fa-chevron-left"></i><span>使用 qtcreator 对 OpenFOAM 代码 debug</span></a></div><div class="next-post pull-right"><a href="/T_calculate/"><span>OpenFOAM 如何从焓得到温度</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk=new Gitalk({clientID:"9dfad189aeefc4c2dde2",clientSecret:"69b4d95e0c4be2508135adae20b05bf6f298f386",repo:"zhangyantju.github.io",owner:"ZhangYanTJU",admin:"ZhangYanTJU",id:md5(decodeURI(location.pathname)),language:"zh-CN"});gitalk.render("gitalk-container")</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By Yan Zhang</div><div class="framework-info"><span>驱动 -</span> <a href="http://hexo.io" target="_blank" rel="external nofollow noopener noreferrer"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 -</span> <a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="external nofollow noopener noreferrer"><span>Melody</span></a></div><div class="footer_custom_text">Hosted by <a target="_blank" rel="external nofollow noopener noreferrer" href="https://pages.coding.me"><b>Coding Pages</b></a></div></div><script id="maid-script" src="https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js?v=undefined"></script><script>if(window.mermaid){var options=JSON.parse(document.getElementById("maid-script").getAttribute("mermaidoptioins"));mermaid.initialize(options)}</script></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"),$("#top-container").addClass("is-mobile"))</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="external nofollow noopener noreferrer" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>